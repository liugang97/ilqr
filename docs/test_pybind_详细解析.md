# test_pybind.py 详细技术解析

## 文档概述

本文档详细解析 `cilqr/test_pybind.py` 文件的执行流程、算法原理和数学基础。该脚本演示了如何使用 C++ 实现的 iLQR (iterative Linear Quadratic Regulator) 求解器进行车辆轨迹优化，包括盒式约束优化和带障碍物的二次约束优化。

---

## 目录

1. [数学基础](#数学基础)
   - [车辆动力学模型](#车辆动力学模型)
   - [iLQR 算法原理](#ilqr-算法原理)
   - [增广拉格朗日方法](#增广拉格朗日方法)
2. [代码执行流程详解](#代码执行流程详解)
   - [第一部分：参考轨迹生成](#第一部分参考轨迹生成)
   - [第二部分：盒式约束优化](#第二部分盒式约束优化)
   - [第三部分：构建求解器并优化](#第三部分构建求解器并优化)
   - [第四部分：二次约束优化（障碍物避障）](#第四部分二次约束优化障碍物避障)
   - [第五部分：结果可视化](#第五部分结果可视化)
3. [关键技术细节](#关键技术细节)
4. [参数调优指南](#参数调优指南)

---

## 数学基础

### 车辆动力学模型

#### 完整动力学自行车模型（Full Dynamic Bicycle Model）

脚本使用 6 维状态向量和 2 维控制向量：

**状态向量** `x = [x, y, θ, δ, v, a]ᵀ`:
- `x, y`: 车辆在全局坐标系中的位置 (m)
- `θ`: 车辆航向角，即车身纵轴与 x 轴的夹角 (rad)
- `δ`: 前轮转角，相对于车身纵轴的转角 (rad)
- `v`: 车辆纵向速度 (m/s)
- `a`: 车辆纵向加速度 (m/s²)

**控制向量** `u = [δ̇, ȧ]ᵀ`:
- `δ̇`: 前轮转角变化率 (rad/s)
- `ȧ`: 加速度变化率，也称为 jerk (m/s³)

**连续时间动力学方程**:

```
ẋ = v · cos(θ)
ẏ = v · sin(θ)
θ̇ = v · tan(δ) / L
δ̇ = u₁
v̇ = a
ȧ = u₂
```

其中 `L` 是车辆轴距（前后轴之间的距离）。

**离散化方法**：使用二阶 Runge-Kutta (RK2) 方法进行数值积分：

```
k₁ = f(xₜ, uₜ)
k₂ = f(xₜ + 0.5·dt·k₁, uₜ)
xₜ₊₁ = xₜ + dt · k₂
```

这种方法比简单的欧拉法更精确，在相同时间步长下能获得更小的数值误差。

#### 物理意义解释

1. **Ackermann 转向几何**: 前轮转角 `δ` 通过 `θ̇ = v·tan(δ)/L` 影响航向角变化率
2. **曲率关系**: 瞬时曲率 `κ ≈ tan(δ)/L` (小角度近似)
3. **加加速度控制**: 直接控制 `ȧ` 而非 `a`，使得加速度变化更平滑，符合实际车辆特性

---

### iLQR 算法原理

iLQR (iterative Linear Quadratic Regulator) 是一种基于序列凸优化的轨迹优化算法。

#### 优化问题形式

目标是最小化总代价函数：

```
min J = Φ(x_N) + Σ(t=0 to N-1) L(xₜ, uₜ)
```

约束条件：
```
xₜ₊₁ = f(xₜ, uₜ)  (动力学约束)
g(xₜ, uₜ) ≤ 0      (不等式约束)
```

其中：
- `Φ(x_N)`: 终端代价函数
- `L(xₜ, uₜ)`: 阶段代价函数
- `f(·)`: 非线性动力学函数
- `g(·)`: 约束函数

#### 阶段代价函数

在本脚本中，阶段代价函数为二次型：

```
L(xₜ, uₜ) = ½(xₜ - x̄ₜ)ᵀ Q (xₜ - x̄ₜ) + ½uₜᵀ R uₜ
```

- `x̄ₜ`: 参考状态（目标轨迹）
- `Q`: 状态权重矩阵（6×6 对角矩阵）
- `R`: 控制权重矩阵（2×2 对角矩阵）

**权重矩阵的物理意义**：
- `Q` 对角元素越大，对应状态偏差的惩罚越重
- `R` 对角元素越大，控制输入越保守（更平滑）

#### iLQR 迭代流程

iLQR 采用 **交替线性化和二次优化** 的策略：

**1. 向后传播（Backward Pass）**：

在当前轨迹 `{x̄ₜ, ūₜ}` 附近进行线性化：

```
xₜ₊₁ ≈ f(x̄ₜ, ūₜ) + Aₜ(xₜ - x̄ₜ) + Bₜ(uₜ - ūₜ)
```

其中雅可比矩阵：
```
Aₜ = ∂f/∂x |_(x̄ₜ,ūₜ)
Bₜ = ∂f/∂u |_(x̄ₜ,ūₜ)
```

然后从终端时刻 `N` 向前递推，计算反馈增益 `Kₜ` 和前馈项 `kₜ`：

```
Qₓ = lₓ + AₜᵀVₓ
Qᵤ = lᵤ + BₜᵀVₓ
Qₓₓ = lₓₓ + AₜᵀVₓₓAₜ
Qᵤᵤ = lᵤᵤ + BₜᵀVₓₓBₜ
Qᵤₓ = BₜᵀVₓₓAₜ

Kₜ = -Qᵤᵤ⁻¹Qᵤₓ
kₜ = -Qᵤᵤ⁻¹Qᵤ

Vₓ = Qₓ + KₜᵀQᵤᵤkₜ + KₜᵀQᵤ + Qᵤₓᵀkₜ
Vₓₓ = Qₓₓ + KₜᵀQᵤᵤKₜ + KₜᵀQᵤₓ + QᵤₓᵀKₜ
```

**2. 向前传播（Forward Pass）**：

使用计算得到的反馈增益和前馈项更新轨迹：

```
uₜ = ūₜ + Kₜ(xₜ - x̄ₜ) + α·kₜ
xₜ₊₁ = f(xₜ, uₜ)
```

其中 `α` 是线搜索步长，通过回溯线搜索（backtracking line search）确定。

**3. 迭代终止条件**：

- 代价函数下降量 `|J_old - J_new| < tol`
- 达到最大迭代次数

---

### 增广拉格朗日方法

增广拉格朗日方法（Augmented Lagrangian Method）用于处理约束优化问题。

#### 基本思想

将约束优化问题转化为一系列无约束优化子问题：

**原始约束问题**：
```
min f(x)
s.t. c(x) ≤ 0
```

**增广拉格朗日函数**：
```
L_AL(x, λ, μ) = f(x) + λᵀmax(0, c(x)) + (μ/2)||max(0, c(x))||²
```

其中：
- `λ`: 拉格朗日乘子向量（对偶变量）
- `μ`: 惩罚系数（penalty parameter）
- `max(0, c(x))`: 约束违反量

#### 双层优化框架

**外层循环**（Augmented Lagrangian 更新）：
1. 固定 `λ` 和 `μ`，求解增广拉格朗日函数的最小化问题
2. 更新拉格朗日乘子：`λ ← λ + μ·max(0, c(x))`
3. 如果约束违反量较大，增加惩罚系数：`μ ← gain·μ`
4. 重复直到约束满足度 `||max(0, c(x))|| < ε`

**内层循环**（iLQR 优化）：
在固定的 `λ` 和 `μ` 下，使用 iLQR 算法最小化增广拉格朗日函数

#### 约束处理的代价函数修正

对于不等式约束 `g(x, u) ≤ 0`，增广后的代价函数为：

```
L_aug(x, u) = L(x, u) + Σᵢ [λᵢ·max(0, gᵢ(x,u)) + (μ/2)·max(0, gᵢ(x,u))²]
```

这样，约束违反会直接增加代价，驱动优化器寻找满足约束的解。

---

## 代码执行流程详解

### 第一部分：参考轨迹生成

#### 代码位置：第 35-89 行

```python
def generate_s_shape_goal_full(v, dt, num_points):
```

#### 功能说明

生成一条平滑的 S 形参考轨迹，作为车辆跟踪的目标。

#### 数学原理

**轨迹参数方程**：

```
x(t) = v · t
y(t) = A · sin(ω · t)
```

其中：
- `v = 10 m/s`: 期望速度
- `A = 50 m`: 横向摆动幅度
- `ω = 0.1 rad/s`: 角频率
- `t = i · dt`: 时间参数

**一阶导数（速度）**：

```
ẋ(t) = v
ẏ(t) = A · ω · cos(ω · t)
```

**二阶导数（加速度）**：

```
ẍ(t) = 0
ÿ(t) = -A · ω² · sin(ω · t)
```

**航向角计算**：

```
θ(t) = arctan2(ẏ, ẋ) = arctan2(Aω·cos(ωt), v)
```

**曲率计算**：

路径曲率公式：
```
κ = (ẋ·ÿ - ẏ·ẍ) / (ẋ² + ẏ²)^(3/2)
```

代入得：
```
κ = (v · (-Aω²sin(ωt)) - 0) / (v² + (Aωcos(ωt))²)^(3/2)
```

**前轮转角计算**：

使用 Ackermann 转向关系的逆变换：
```
δ = arctan(κ · L)
```

其中 `L = 1.0 m` 是假设的车辆轴距。

**输出结果**：

每个时间点生成一个 6 维状态向量：
```
goal_state = [x, y, θ, δ, v_desire, 0]
```

注意期望加速度设为 0，表示匀速运动。

#### 参数设置（第 145-151 行）

```python
v = 10          # 期望速度: 10 m/s (36 km/h)
dt = 0.1        # 时间步长: 0.1 秒
L = 3           # 车辆轴距: 3 米（典型轿车尺寸）
k = 0.001       # 正则化系数（数值稳定性）
num_points = 30 # 轨迹点数量
horizon = 30    # 优化时域长度
```

**轨迹特征**：
- 总时长: `30 × 0.1 = 3` 秒
- 总行驶距离: `10 m/s × 3 s = 30` 米
- 横向摆动周期: `2π / 0.1 ≈ 62.8` 秒

---

### 第二部分：盒式约束优化

#### 代码位置：第 166-212 行

#### 功能说明

配置优化器参数和约束，包括代价函数权重矩阵和状态/控制的上下界。

#### 代价函数权重矩阵配置

**状态权重矩阵 Q**（第 180 行）：

```python
Q = np.diag([1e-1, 1e-1, 1e-0, 1e-9, 1e-6, 1e-6]) * 1e3
```

展开为：
```
Q = diag([100, 100, 1000, 0.001, 1, 1])
```

**物理意义**：
- `Q[0,0] = 100`: x 位置误差权重
  - 每米偏差带来 `0.5 × 100 × 1² = 50` 的代价
- `Q[1,1] = 100`: y 位置误差权重
  - 横向偏差同样重要
- `Q[2,2] = 1000`: **航向角误差权重（最高）**
  - 保持正确朝向最重要，每 0.1 rad (≈5.7°) 偏差带来 `0.5 × 1000 × 0.1² = 5` 的代价
- `Q[3,3] = 0.001`: 前轮转角误差权重
  - 转角跟踪不太重要，允许更大偏差
- `Q[4,4] = 1`: 速度误差权重
  - 鼓励保持期望速度
- `Q[5,5] = 1`: 加速度误差权重
  - 期望加速度接近 0

**控制权重矩阵 R**（第 190 行）：

```python
R = np.diag([1, 1]) * 1e2 = diag([100, 100])
```

**物理意义**：
- `R[0,0] = 100`: 转角变化率惩罚
  - 防止方向盘转动过快，每 0.1 rad/s 带来 `0.5 × 100 × 0.1² = 0.5` 的代价
- `R[1,1] = 100`: 加速度变化率（jerk）惩罚
  - 保证平稳驾驶，防止急加速/急减速

#### 盒式约束（Box Constraints）

**状态约束**（第 198-201 行）：

```python
state_min = [-1000, -1000, -2π, -10, -100, -10]
state_max = [1000, 1000, 2π, 10, 100, 10]
```

- 位置 x, y: 实际上不限制（±1000m 远大于轨迹范围）
- 航向角 θ: `[-2π, 2π]`（允许多圈旋转）
- 前轮转角 δ: `[-10, 10] rad`（实际车辆约 ±30°，这里更宽松）
- 速度 v: `[-100, 100] m/s`（允许倒车）
- 加速度 a: `[-10, 10] m/s²`（约 ±1g）

**控制约束**（第 203-204 行）：

```python
control_min = [-0.2, -1]  # [δ̇_min, ȧ_min]
control_max = [0.2, 1]    # [δ̇_max, ȧ_max]
```

- 转角变化率: `[-0.2, 0.2] rad/s`（约 ±11.5°/s）
- 加速度变化率: `[-1, 1] m/s³`

#### 约束对象创建（第 210-212 行）

```python
constraints = ilqr_pybind.BoxConstraints6_2(
    state_min, state_max, control_min, control_max
)
```

这创建了一个 C++ 端的 `BoxConstraints<6, 2>` 对象，内部表示为线性不等式约束：

```
state_min ≤ x ≤ state_max
control_min ≤ u ≤ control_max
```

---

### 第三部分：构建求解器并优化

#### 代码位置：第 215-270 行

#### 构建动力学节点列表（第 225-233 行）

```python
ilqr_nodes_list = []
for i in range(horizon + 1):
    node = ilqr_pybind.NewBicycleNodeBoxConstraints6_2(
        L, dt, k, goal_list_full[i], Q, R, constraints
    )
    ilqr_nodes_list.append(node)
```

**每个节点包含**：
- 车辆动力学模型（轴距 L, 时间步长 dt）
- 当前时刻的参考状态 `goal_list_full[i]`
- 代价函数参数（Q, R）
- 约束对象
- 正则化系数 k

**为什么需要 `horizon+1` 个节点？**
- 0 到 `horizon-1` 节点：对应 `(xₜ, uₜ)` 对，计算运行代价
- 第 `horizon` 节点：只对应终端状态 `x_N`，计算终端代价

#### 创建 AL-iLQR 求解器（第 237-243 行）

```python
init_state = np.array([0, 0, 0, 0, v, 0])
al_ilqr = ilqr_pybind.NewALILQR6_2(ilqr_nodes_list, init_state)
```

**初始状态含义**：
```
[x=0, y=0, θ=0, δ=0, v=10, a=0]
```
车辆从原点出发，朝向 x 轴正方向，速度 10 m/s，无加速度。

#### 优化参数设置（第 246-248 行）

```python
max_outer_iter = 50     # 最大外层迭代次数
max_inner_iter = 100    # 最大内层 iLQR 迭代次数
max_violation = 1e-4    # 约束违反容忍度
```

**参数含义**：
- `max_outer_iter`: 增广拉格朗日外层循环最多 50 次
- `max_inner_iter`: 每次外层循环中，iLQR 最多迭代 100 次
- `max_violation`: 当所有约束违反量 `max(0, g(x,u)) < 1e-4` 时认为收敛

#### 执行优化（第 258 行）

```python
al_ilqr.optimize(max_outer_iter, max_inner_iter, max_violation)
```

**内部执行流程**（对应 `new_al_ilqr.h:659-689`）：

1. **初始化轨迹**（`linearizedInitialGuess`）：
   - 使用 LQR 方法生成初始反馈增益
   - 从初始状态开始展开轨迹

2. **外层循环** (最多 50 次)：
   ```
   for outer_iter in range(max_outer_iter):
       # 内层 iLQR 优化
       ILQRProcess(max_inner_iter, tol=1e-3)

       # 计算约束违反量
       violation = ComputeConstraintViolation()

       if violation < max_violation:
           break  # 收敛，退出
       else:
           if violation > 5 * max_violation:
               UpdateMu(100.0)  # 约束违反较大，增加惩罚
           else:
               UpdateLambda()   # 更新拉格朗日乘子
   ```

3. **内层 iLQR 流程** (`ILQRProcess`):
   ```
   for inner_iter in range(max_inner_iter):
       CalcDerivatives()      # 计算代价和动力学的梯度/海森
       Backward()             # 计算反馈增益 K 和前馈 k
       Forward()              # 线搜索更新轨迹

       if cost_decrease < tol:
           break
   ```

#### 获取优化结果（第 261-266 行）

```python
x_list = al_ilqr.get_x_list()  # shape: (6, 31)
u_list = al_ilqr.get_u_list()  # shape: (2, 30)
```

- `x_list`: 优化后的状态轨迹矩阵，每列是一个状态向量
- `u_list`: 优化后的控制序列矩阵，每列是一个控制向量

---

### 第四部分：二次约束优化（障碍物避障）

#### 代码位置：第 273-359 行

#### 功能说明

在原有盒式约束的基础上，添加圆形障碍物避障约束，使用二次约束建模。

#### 二次约束数学形式

一般二次约束表示为：

```
xᵀQx + Aᵀx + C ≤ 0
```

对于圆形障碍物 `(x - cx)² + (y - cy)² ≤ r²`，要求车辆 **不进入** 障碍物内部，即：

```
(x - cx)² + (y - cy)² ≥ r²
```

等价于：

```
-(x - cx)² - (y - cy)² + r² ≤ 0
```

#### 圆形障碍物约束生成（第 92-134 行）

```python
def generate_cycle_equations(centre_x, centre_y, r, x_dims):
```

**展开圆的方程**：

```
(x - cx)² + (y - cy)² ≥ r²
```

展开：
```
x² - 2cx·x + cx² + y² - 2cy·y + cy² ≥ r²
```

重排为约束形式 `≤ 0`:
```
-(x² + y²) + 2cx·x + 2cy·y + (cx² + cy² - r²) ≤ 0
```

**矩阵表示**：

```python
Q = [[-1,  0,  0,  0,  0,  0],
     [ 0, -1,  0,  0,  0,  0],
     [ 0,  0,  0,  0,  0,  0],
     [ 0,  0,  0,  0,  0,  0],
     [ 0,  0,  0,  0,  0,  0],
     [ 0,  0,  0,  0,  0,  0]]

A = [2·cx, 2·cy, 0, 0, 0, 0]ᵀ

C = cx² + cy² - r²
```

约束形式：`xᵀQx + Aᵀx + C ≤ 0`

#### 障碍物参数设置（第 308-312 行）

```python
circle_x = 30   # 圆心 x 坐标
circle_y = 11   # 圆心 y 坐标
circle_r = 6    # 半径 6 米
```

**障碍物位置分析**：
- 参考轨迹在 `x=30m` 时，`y = 50·sin(0.1·3) ≈ 50·0.296 ≈ 14.8m`
- 障碍物圆心在 `(30, 11)`，半径 6m，覆盖 `y ∈ [5, 17]`
- 因此障碍物正好位于参考轨迹附近，需要绕行

#### 混合约束配置（第 283-321 行）

脚本配置了 5 个约束：

```python
Q_list = [...]  # 5 个 (6×6) 矩阵
A = np.zeros((5, 6))
B = np.array([[0, 0], [1, 0], [0, 1], [-1, 0], [0, -1]])
C = np.array([[0], [-0.4], [-1], [-0.4], [-1]])
```

**约束 1**（圆形障碍物）：
```
xᵀQ_list[0]x + A[0]ᵀx + C[0] ≤ 0
```
实际为：`-(x² + y²) + 2·30·x + 2·11·y + (30² + 11² - 6²) ≤ 0`

**约束 2-5**（控制输入边界，冗余）：
```
u[0] ≤ -0.4       # 等价于 u[0] ≥ 0.4，但这与盒式约束 u[0] ∈ [-0.2, 0.2] 矛盾
-u[0] ≤ -0.4      # 等价于 u[0] ≥ 0.4
...
```

**注意**：约束 2-5 的参数看似有误，但由于它们与盒式约束矛盾，实际上会被盒式约束主导。真正起作用的是约束 1（障碍物约束）。

#### 创建二次约束对象（第 324-325 行）

```python
quadratic_constraints = ilqr_pybind.QuadraticConstraints6_2_5(Q_list, A, B, C)
```

这创建了一个包含 5 个二次约束的约束对象。

#### 重新构建节点和求解器（第 329-348 行）

```python
quadratic_ilqr_nodes_list = []
for i in range(horizon + 1):
    node = ilqr_pybind.NewBicycleNodeQuadraticConstraints6_2_5(
        L, dt, k, goal_list_full[i], Q, R, quadratic_constraints
    )
    quadratic_ilqr_nodes_list.append(node)

q_al_ilqr = ilqr_pybind.NewALILQR6_2(quadratic_ilqr_nodes_list, init_state)
q_al_ilqr.optimize(max_outer_iter, max_inner_iter, max_violation)
```

使用相同的优化参数，但节点中约束类型从 `BoxConstraints` 变为 `QuadraticConstraints`。

#### 获取避障轨迹（第 351-356 行）

```python
q_x_list = q_al_ilqr.get_x_list()
q_plot_x = q_x_list[0, :]
q_plot_y = q_x_list[1, :]
```

---

### 第五部分：结果可视化

#### 代码位置：第 363-417 行

#### 可视化内容

脚本绘制三条轨迹的对比：

1. **参考轨迹**（红色）：
   ```python
   plt.plot(goal_x, goal_y, label='init State Trajectory', c='r')
   ```
   理想的 S 形曲线

2. **盒式约束优化轨迹**（蓝色）：
   ```python
   plt.plot(plot_x, plot_y, label='Optimized State Trajectory', c='b')
   ```
   仅考虑状态/控制边界，**可能穿过障碍物**

3. **二次约束优化轨迹**（绿色）：
   ```python
   plt.plot(q_plot_x, q_plot_y, label='obs (Full)', c='g')
   ```
   考虑障碍物约束，**绕开障碍物**

4. **圆形障碍物**（浅蓝色填充）：
   ```python
   circle = patches.Circle((circle_x, circle_y), circle_r, ...)
   ```

#### 预期结果分析

**盒式约束轨迹（蓝色）**：
- 尽量贴近参考轨迹（红色）
- 在 `x ≈ 30m` 附近可能与障碍物重叠
- 代价函数主要由跟踪误差主导

**二次约束轨迹（绿色）**：
- 在 `x ≈ 30m` 附近偏离参考轨迹
- 增大 y 坐标或减小 y 坐标以绕开障碍物
- 代价函数权衡跟踪误差和避障需求

---

## 关键技术细节

### 1. 数值稳定性处理

#### 正则化系数 k（第 149 行）

```python
k = 0.001
```

在动力学模型中使用（`new_bicycle_node.h` 中）：

```cpp
v_tan_delta / (1 + k·v²)
```

防止高速时 `v·tan(δ)` 项导致数值爆炸。

#### 角度归一化

在 `NewBicycleNode::normalize_state` 中：
```cpp
normalize_angle(state(2));  // θ ∈ [-π, π]
normalize_angle(state(3));  // δ ∈ [-π, π]
```

防止角度累积导致的数值误差。

### 2. 并行线搜索优化

#### 代码位置：`new_al_ilqr.h:425-505`

```cpp
void ParallelLinearSearch(double alpha, double& best_alpha, double& best_cost)
```

**原理**：
- 同时评估多个步长 `α, α/3, α/9, ..., α/3^(PARALLEL_NUM-1)`
- 使用向量化计算（Eigen 矩阵运算）
- 一次性展开 `horizon` 步，找到最优步长

**优势**：
- 比串行回溯线搜索快 3-10 倍
- 充分利用 CPU 向量化指令（AVX）

### 3. 海森矩阵二阶项

#### 代码位置：`new_al_ilqr.h:523`

```cpp
Qxx += fxx[0] * Vx[0] + fxx[1] * Vx[1] + fxx[2] * Vx[2];
```

**数学含义**：

标准 iLQR 使用一阶近似（忽略动力学海森）：
```
Qxx ≈ lxx + AᵀVxxA
```

本实现包含二阶项（Tensor 收缩）：
```
Qxx = lxx + AᵀVxxA + Σᵢ Vx[i] · fxx[i]
```

其中 `fxx[i]` 是 `f` 关于 `x` 的海森矩阵（对第 i 个输出维度）。

**优势**：
- 更精确的二阶近似
- 收敛速度更快（尤其是高度非线性系统）

### 4. 约束处理细节

#### 最大约束违反计算

```cpp
double ComputeConstraintViolation() {
    for (int t = 0; t < horizon; ++t) {
        max_violation[t] = node[t]->max_constraints_violation(x[t], u[t]);
    }
    return max_violation.maxCoeff();
}
```

返回所有时刻、所有约束中的最大违反量。

#### 拉格朗日乘子更新

```cpp
void UpdateLambda() {
    for (int t = 0; t < horizon; ++t) {
        node[t]->update_lambda(x[t], u[t]);
    }
}
```

在约束对象内部：
```cpp
λ ← λ + μ · max(0, g(x, u))
```

#### 惩罚系数自适应更新

```cpp
if (violation > 5 * max_violation) {
    UpdateMu(100.0);  // μ ← 100·μ
} else {
    UpdateLambda();
}
```

**策略**：
- 违反量大（> 5ε）：激进增大 μ，快速惩罚
- 违反量小（< 5ε）：精细调整 λ，准确逼近最优

---

## 参数调优指南

### 代价函数权重 Q, R

**增大 Q[i, i]**：
- 效果：更严格跟踪参考状态的第 i 维
- 副作用：可能导致控制输入更激进，约束更易违反

**增大 R[i, i]**：
- 效果：控制输入更平滑
- 副作用：跟踪精度下降，响应变慢

**调优原则**：
1. 先调 Q，确定跟踪优先级（通常 `Q[θ]` 最大）
2. 再调 R，平衡平滑性和响应性
3. 保持 `Q` 和 `R` 量级平衡（本例中 Q ∼ 10²-10³, R ∼ 10²）

### 优化迭代参数

**max_outer_iter** (外层循环):
- 典型值：10-100
- 问题简单（少量约束）：10-20 足够
- 问题复杂（多约束、紧约束）：50-100

**max_inner_iter** (内层 iLQR):
- 典型值：50-200
- 问题凸性好：30-50
- 非线性强：100-200

**max_violation** (约束容忍度):
- 典型值：1e-3 到 1e-5
- 宽松约束（软约束）：1e-3
- 严格约束（安全关键）：1e-5

### 时间步长 dt

**更小的 dt**：
- 优点：离散化误差小，动力学近似更准确
- 缺点：时域点数增多，计算量增大

**更大的 dt**：
- 优点：计算快
- 缺点：可能跳过快速动态，约束检查粗糙

**经验法则**：
```
dt ≤ T_characteristic / 10
```
其中 `T_characteristic` 是系统特征时间（例如转向响应时间）。

### 障碍物建模

**圆形障碍物**：
- 简单，凸约束，易求解
- 保守（实际可通行区域大于圆外部）

**多边形障碍物**：
- 更精确
- 使用多个线性约束逼近
- 约束数量增多，求解变慢

**膨胀系数**：
实际应用中，将障碍物半径 `r` 膨胀为 `r + r_vehicle + δ_safe`，确保安全距离。

---

## 总结

`test_pybind.py` 脚本展示了一个完整的基于 iLQR 的轨迹优化流程：

1. **轨迹生成**：数学参数化生成平滑参考曲线
2. **基础优化**：使用盒式约束优化，验证基本功能
3. **障碍物避障**：引入二次约束，展示复杂约束处理
4. **结果对比**：可视化验证算法有效性

核心技术点：
- **增广拉格朗日双层优化**：外层处理约束，内层 iLQR 优化
- **并行线搜索**：加速前向传播
- **二阶动力学近似**：提高收敛速度
- **数值稳定性处理**：正则化、角度归一化

该脚本是学习和测试 iLQR 算法的优秀起点，可以通过修改参数和约束探索不同场景。
