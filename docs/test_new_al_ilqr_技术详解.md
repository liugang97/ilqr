# test_new_al_ilqr.cc 技术详解

> 本文档详细解析 `cilqr/al_ilqr_cpp/test_new_al_ilqr.cc` 测试程序的执行流程、算法原理和数学基础。

## 目录

- [1. 文件概述](#1-文件概述)
- [2. 执行流程图](#2-执行流程图)
- [3. 数学原理](#3-数学原理)
  - [3.1 自行车运动学模型](#31-自行车运动学模型)
  - [3.2 轨迹优化问题](#32-轨迹优化问题)
  - [3.3 iLQR 算法](#33-ilqr-算法)
  - [3.4 增广拉格朗日法](#34-增广拉格朗日法)
  - [3.5 约束处理](#35-约束处理)
- [4. 代码执行流程详解](#4-代码执行流程详解)
  - [4.1 参数初始化](#41-参数初始化)
  - [4.2 S 形参考轨迹生成](#42-s-形参考轨迹生成)
  - [4.3 测试一：盒式约束优化](#43-测试一盒式约束优化)
  - [4.4 测试二：二次约束优化](#44-测试二二次约束优化)
- [5. 算法实现细节](#5-算法实现细节)
- [6. 参数调优指南](#6-参数调优指南)

---

## 1. 文件概述

### 1.1 功能描述

`test_new_al_ilqr.cc` 是一个测试程序，用于验证增广拉格朗日 iLQR (Augmented Lagrangian iterative Linear Quadratic Regulator) 求解器在车辆轨迹规划问题上的性能。

### 1.2 测试场景

该程序包含两个测试场景：

1. **盒式约束场景**：车辆跟踪 S 形参考轨迹，受状态和控制的上下界约束
2. **二次约束场景**：车辆跟踪 S 形参考轨迹，同时避开圆形障碍物

### 1.3 核心组件

- **车辆模型**：完整动力学自行车模型（6 维状态，2 维控制）
- **优化算法**：增广拉格朗日 iLQR
- **约束类型**：盒式约束 (BoxConstraints)、二次约束 (QuadraticConstraints)

---

## 2. 执行流程图

```
┌─────────────────────────────────────────────────────────────┐
│                     程序启动 (main)                          │
└─────────────────────────────────────────────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────────┐
│              第一部分：参数设置                              │
│  • 基本参数: v=10m/s, dt=0.1s, L=3.0m, num_points=50       │
│  • 生成 S 形参考轨迹 (51 个点)                               │
│  • 设置代价权重矩阵: Q (6×6), R (2×2)                       │
└─────────────────────────────────────────────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────────┐
│            测试一：盒式约束优化                              │
├─────────────────────────────────────────────────────────────┤
│  1. 定义状态约束: [-1000~1000, -1000~1000, ...]            │
│  2. 定义控制约束: δ_rate ∈ [-0.2, 0.2], a_rate ∈ [-1, 1]  │
│  3. 创建盒式约束对象 BoxConstraints<6, 2>                   │
│  4. 创建 51 个 NewBicycleNode (每个时间步一个)               │
│  5. 初始化求解器 NewALILQR<6,2>                             │
│  6. 执行优化: solver.optimize(50, 100, 1e-3)                │
│     ├─ 外层循环 (最多 50 次): 更新拉格朗日乘子 λ 和惩罚系数 μ │
│     └─ 内层循环 (最多 100 次): iLQR 迭代                     │
│         ├─ Backward Pass: 计算反馈增益 K 和前馈项 k          │
│         └─ Forward Pass: 线搜索更新轨迹                      │
│  7. 输出优化结果: 控制序列 u 和状态轨迹 x                     │
└─────────────────────────────────────────────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────────┐
│            测试二：二次约束优化（圆形障碍物）                 │
├─────────────────────────────────────────────────────────────┤
│  1. 定义 5 个二次约束:                                       │
│     • 约束 0: 圆形障碍物 (x=20, y=12, r=4)                   │
│     • 约束 1-4: 控制界限约束                                 │
│  2. 生成圆形障碍物方程系数 (Q, A, C)                         │
│     圆形约束: -x² - y² + 2·20·x + 2·12·y + (16-544) ≤ 0    │
│  3. 创建二次约束对象 QuadraticConstraints<6, 2, 5>          │
│  4. 创建 51 个带二次约束的 NewBicycleNode                    │
│  5. 初始化求解器 NewALILQR<6,2>                             │
│  6. 执行优化: q_solver.optimize(30, 100, 1e-3)              │
│  7. 输出优化结果: 控制序列 u 和状态轨迹 x                     │
└─────────────────────────────────────────────────────────────┘
                            │
                            ▼
                      程序结束
```

---

## 3. 数学原理

### 3.1 自行车运动学模型

#### 3.1.1 状态变量和控制变量

**状态向量** (6 维):
```
x = [x, y, θ, δ, v, a]ᵀ
```

其中：
- `x, y`: 车辆位置坐标 (m)
- `θ`: 航向角 (rad)
- `δ`: 前轮转角 (rad)
- `v`: 纵向速度 (m/s)
- `a`: 纵向加速度 (m/s²)

**控制向量** (2 维):
```
u = [δ_rate, a_rate]ᵀ
```

其中：
- `δ_rate`: 前轮转角变化率 (rad/s)
- `a_rate`: 加速度变化率（急动度 jerk, m/s³）

#### 3.1.2 连续时间动力学方程

自行车模型的连续时间动态方程为：

```
ẋ = v · cos(θ)
ẏ = v · sin(θ)
θ̇ = (v / L) · tan(δ)
δ̇ = δ_rate
v̇ = a
ȧ = a_rate
```

其中 `L` 是车辆轴距 (在测试中 L = 3.0 m)。

#### 3.1.3 离散化 (RK2 积分)

采用二阶 Runge-Kutta (RK2) 方法进行离散化：

```
k₁ = f(xₖ, uₖ)
k₂ = f(xₖ + dt·k₁, uₖ)
xₖ₊₁ = xₖ + (dt/2) · (k₁ + k₂)
```

这比简单的欧拉法 `xₖ₊₁ = xₖ + dt·f(xₖ, uₖ)` 提供更高的精度。

### 3.2 轨迹优化问题

#### 3.2.1 标准形式

轨迹优化问题可以表示为：

```
minimize    J = Σₖ₌₀ᴺ⁻¹ l(xₖ, uₖ) + lf(xₙ)

subject to  xₖ₊₁ = f(xₖ, uₖ),  k = 0, ..., N-1
            c(xₖ, uₖ) ≤ 0,      k = 0, ..., N-1
            x₀ = x_init
```

其中：
- `J`: 总代价函数
- `l(xₖ, uₖ)`: 阶段代价（运行成本）
- `lf(xₙ)`: 终端代价
- `f(xₖ, uₖ)`: 动力学约束
- `c(xₖ, uₖ)`: 路径约束

#### 3.2.2 代价函数设计

在本测试中，阶段代价为二次型：

```
l(xₖ, uₖ) = (xₖ - xₖʳᵉᶠ)ᵀ Q (xₖ - xₖʳᵉᶠ) + uₖᵀ R uₖ
```

**状态权重矩阵 Q** (对角矩阵):
```
Q = diag([100, 100, 1000, 0.001, 1, 1])
```
说明：
- `Q[0,0] = 100`: x 位置跟踪权重
- `Q[1,1] = 100`: y 位置跟踪权重
- `Q[2,2] = 1000`: 航向角 θ 跟踪权重（最高）
- `Q[3,3] = 0.001`: 前轮转角 δ 权重（很低，允许自由调整）
- `Q[4,4] = 1`: 速度 v 权重
- `Q[5,5] = 1`: 加速度 a 权重

**控制权重矩阵 R** (对角矩阵):
```
R = diag([100, 100])
```
说明：
- `R[0,0] = 100`: 转向速率惩罚（避免急转向）
- `R[1,1] = 100`: 加加速度惩罚（保证舒适性）

### 3.3 iLQR 算法

#### 3.3.1 算法思想

iLQR (iterative Linear Quadratic Regulator) 是一种局部轨迹优化算法，通过迭代求解近似的 LQR 子问题来优化非线性系统的轨迹。

**核心思想**：
1. 在当前轨迹附近对动力学和代价函数进行泰勒展开（线性化和二次化）
2. 求解近似的 LQR 问题，得到控制修正量
3. 通过线搜索更新轨迹
4. 重复直到收敛

#### 3.3.2 Backward Pass（反向传播）

从终端时刻 N 向初始时刻 0 反向传播，计算值函数和控制策略。

**值函数二次近似**：

在时刻 k，值函数近似为：

```
V(δx) ≈ V₀ + Vₓᵀ δx + (1/2) δxᵀ Vₓₓ δx
```

**Q 函数（状态-动作值函数）**：

```
Qₓ  = lₓ + fₓᵀ Vₓ'
Qᵤ  = lᵤ + fᵤᵀ Vₓ'
Qₓₓ = lₓₓ + fₓᵀ Vₓₓ' fₓ
Qᵤᵤ = lᵤᵤ + fᵤᵀ Vₓₓ' fᵤ
Qₓᵤ = lₓᵤ + fₓᵀ Vₓₓ' fᵤ
```

其中：
- `lₓ, lᵤ, lₓₓ, lᵤᵤ, lₓᵤ`: 代价函数的导数
- `fₓ, fᵤ`: 动力学函数的雅可比矩阵
- `Vₓ', Vₓₓ'`: 下一时刻的值函数导数

**最优控制修正**：

```
δu* = -Qᵤᵤ⁻¹ (Qᵤ + Qᵤₓ δx)
    = k + K δx
```

其中：
- **前馈项**: `k = -Qᵤᵤ⁻¹ Qᵤ`
- **反馈增益**: `K = -Qᵤᵤ⁻¹ Qᵤₓ`

**值函数更新**：

```
Vₓ  = Qₓ - Kᵀ Qᵤᵤ K
Vₓₓ = Qₓₓ - Kᵀ Qᵤᵤ K
```

#### 3.3.3 Forward Pass（前向传播）

使用线搜索找到合适的步长 α，更新轨迹：

```
uₖⁿᵉʷ = uₖᵒˡᵈ + α·k + K·(xₖⁿᵉʷ - xₖᵒˡᵈ)
xₖ₊₁ⁿᵉʷ = f(xₖⁿᵉʷ, uₖⁿᵉʷ)
```

**线搜索策略**：

测试程序使用并行线搜索，同时评估多个候选步长（通常 α ∈ {1.0, 0.5, 0.25, ...}），选择代价最小的一个。

### 3.4 增广拉格朗日法

#### 3.4.1 基本原理

增广拉格朗日法是处理约束优化问题的经典方法，通过引入拉格朗日乘子和惩罚项将约束问题转换为无约束问题。

**原始约束优化问题**：

```
minimize    J(x, u)
subject to  c(x, u) ≤ 0
```

**增广拉格朗日函数**：

```
Lₐ(x, u, λ, μ) = J(x, u) + Σᵢ λᵢ·max(0, cᵢ(x,u)) + (μ/2)·Σᵢ max(0, cᵢ(x,u))²
```

其中：
- `λ = [λ₁, λ₂, ..., λₘ]`: 拉格朗日乘子向量
- `μ`: 惩罚系数（标量）
- `max(0, cᵢ)`: 约束违反量（只惩罚被违反的约束）

#### 3.4.2 双层迭代结构

**外层循环** (更新 λ 和 μ)：

```
For outer_iter = 1 to max_outer_iter:
    1. 执行内层 iLQR 优化（固定 λ 和 μ）
    2. 计算约束违反: vᵢ = max(0, cᵢ(x*, u*))
    3. 更新拉格朗日乘子: λᵢ ← max(0, λᵢ + μ·vᵢ)
    4. 检查约束满足度: 如果 ||v|| < tol，收敛
    5. 否则，增加惩罚系数: μ ← β·μ (通常 β = 10)
```

**内层循环** (固定 λ 和 μ，执行 iLQR)：

```
For inner_iter = 1 to max_inner_iter:
    1. 计算增广代价函数的导数（包含约束惩罚项）
    2. Backward Pass: 计算 K 和 k
    3. Forward Pass: 线搜索更新轨迹
    4. 检查收敛性
```

#### 3.4.3 约束违反度量

约束违反的总度量：

```
violation = √(Σᵢ max(0, cᵢ(xₖ, uₖ))²)
```

当 `violation < max_violation`（测试中为 1e-3）时，认为约束满足，算法终止。

### 3.5 约束处理

#### 3.5.1 盒式约束 (Box Constraints)

盒式约束是最简单的约束形式，表示状态和控制的上下界：

```
x_min ≤ x ≤ x_max
u_min ≤ u ≤ u_max
```

在测试一中的约束设置：

**状态约束**：
```
-1000 ≤ x ≤ 1000        (位置 x)
-1000 ≤ y ≤ 1000        (位置 y)
-2π ≤ θ ≤ 2π            (航向角)
-10 ≤ δ ≤ 10            (前轮转角)
-100 ≤ v ≤ 100          (速度)
-10 ≤ a ≤ 10            (加速度)
```

**控制约束**：
```
-0.2 ≤ δ_rate ≤ 0.2     (转向速率限制)
-1 ≤ a_rate ≤ 1         (加加速度限制)
```

这些约束可以转换为标准形式 `c(x, u) ≤ 0`：

```
x - x_max ≤ 0
x_min - x ≤ 0
...
```

#### 3.5.2 二次约束 (Quadratic Constraints)

二次约束的一般形式：

```
xᵀ Qᵢ x + Aᵢᵀ x + Bᵢᵀ u + Cᵢ ≤ 0
```

**圆形障碍物约束**：

原始形式（车辆必须在圆外）：
```
(x - xₒ)² + (y - yₒ)² ≥ r²
```

转换为标准二次约束形式：
```
-(x - xₒ)² - (y - yₒ)² + r² ≤ 0
```

展开：
```
-x² - y² + 2xₒ·x + 2yₒ·y + (r² - xₒ² - yₒ²) ≤ 0
```

对应系数矩阵（测试二中障碍物位置 (20, 12)，半径 4m）：

```
Q = [-1  0  0  0  0  0]
    [ 0 -1  0  0  0  0]
    [ 0  0  0  0  0  0]
    [ 0  0  0  0  0  0]
    [ 0  0  0  0  0  0]
    [ 0  0  0  0  0  0]

A = [2×20, 2×12, 0, 0, 0, 0] = [40, 24, 0, 0, 0, 0]

C = 4² - 20² - 12² = 16 - 400 - 144 = -528
```

**控制界限的线性约束**：

在二次约束框架中，控制界限也表示为二次约束（Q=0 的特殊情况）：

```
约束 1: δ_rate ≤ 0.2       →  B₁ = [1, 0],  C₁ = -0.2
约束 2: a_rate ≤ 1         →  B₂ = [0, 1],  C₂ = -1
约束 3: δ_rate ≥ -0.2      →  B₃ = [-1, 0], C₃ = -0.2
约束 4: a_rate ≥ -1        →  B₄ = [0, -1], C₄ = -1
```

---

## 4. 代码执行流程详解

### 4.1 参数初始化

```cpp
// 基本参数
double v = 10;          // 期望速度 10 m/s (36 km/h)
double dt = 0.1;        // 时间步长 0.1 秒
double L = 3.0;         // 车辆轴距 3.0 米（典型轿车尺寸）
int num_points = 50;    // 轨迹点数 50 个，总时长 5 秒
```

**时间离散化**：
- 总时间跨度：`T = num_points × dt = 50 × 0.1 = 5 秒`
- 离散点数：51 个（包括初始点 k=0 到终端点 k=50）

### 4.2 S 形参考轨迹生成

#### 4.2.1 轨迹参数方程

```cpp
double x = v * t;                      // x(t) = 10t
double y = 50 * std::sin(0.1 * t);     // y(t) = 50·sin(0.1t)
```

**轨迹特性**：
- x 方向：匀速直线运动，速度 10 m/s
- y 方向：正弦振荡，振幅 50 m，周期 T = 2π/0.1 ≈ 62.8 秒
- 在 5 秒内，正弦波完成约 0.08 个周期（轻微的 S 形弯曲）

#### 4.2.2 几何量计算

**航向角**：

轨迹的切线方向：
```
θ(t) = atan2(dy/dt, dx/dt) = atan2(5·cos(0.1t), 10)
```

**曲率**：

使用曲率公式：
```
κ = (ẋ·ÿ - ẏ·ẍ) / (ẋ² + ẏ²)^(3/2)
```

其中：
```
ẋ = 10
ẏ = 5·cos(0.1t)
ẍ = 0
ÿ = -0.5·sin(0.1t)
```

代入：
```
κ = (10 × (-0.5·sin(0.1t)) - 5·cos(0.1t) × 0) / (100 + 25·cos²(0.1t))^(3/2)
  = -5·sin(0.1t) / (100 + 25·cos²(0.1t))^(3/2)
```

**前轮转角**：

根据自行车模型的几何关系：
```
δ = atan(L · κ) = atan(1.0 · κ)  // 代码中假设 L=1.0 用于计算 δ
```

注意：这里的 L=1.0 是用于从曲率推导 δ 的假设值，实际车辆模型的轴距仍然是 3.0m。

#### 4.2.3 生成的轨迹示例

| 时间 t | x (m) | y (m) | θ (rad) | δ (rad) | v (m/s) | a (m/s²) |
|--------|-------|-------|---------|---------|---------|----------|
| 0.0    | 0     | 0     | ~0.464  | 0       | 10      | 0        |
| 1.0    | 10    | 4.99  | ~0.464  | ~-0.005 | 10      | 0        |
| 2.5    | 25    | 12.28 | ~0.416  | ~-0.012 | 10      | 0        |
| 5.0    | 50    | 23.97 | ~0.268  | ~-0.023 | 10      | 0        |

### 4.3 测试一：盒式约束优化

#### 4.3.1 代价矩阵设置

```cpp
// 状态代价矩阵 Q
Q_fast.diagonal() << 1e-1, 1e-1, 1e-0, 1e-9, 1e-6, 1e-6;
Q_fast *= 1e3;
// 结果: diag([100, 100, 1000, 0.001, 1, 1])

// 控制代价矩阵 R
R_fast = I₂ₓ₂ * 100;
// 结果: diag([100, 100])
```

**权重设计理念**：
- **高权重** (`Q[2,2] = 1000`): 航向角跟踪，确保车辆朝向正确
- **中等权重** (`Q[0,0] = Q[1,1] = 100`): 位置跟踪
- **低权重** (`Q[3,3] = 0.001`): 前轮转角，给予充分自由度
- **控制平滑** (`R = 100 I`): 惩罚控制变化，保证舒适性

#### 4.3.2 约束设置

盒式约束对象：
```cpp
BoxConstraints<6, 2> constraints_obj(
    state_bounds[0],   // 状态下界
    state_bounds[1],   // 状态上界
    control_bounds[0], // 控制下界
    control_bounds[1]  // 控制上界
);
```

这些约束在优化过程中通过增广拉格朗日项进入代价函数。

#### 4.3.3 节点创建

为每个时间步 `k = 0, 1, ..., 50` 创建一个 `NewBicycleNode`：

```cpp
for (int i = 0; i <= num_points; ++i) {
    ilqr_node_list.push_back(
        std::make_shared<NewBicycleNode<BoxConstraints<6, 2>>>(
            L,                 // 轴距 3.0m
            dt,                // 时间步长 0.1s
            0.001,             // 正则化系数 k（防止数值问题）
            goal_list_fast[i], // 第 i 个参考状态
            Q_fast,            // 状态代价矩阵
            R_fast,            // 控制代价矩阵
            constraints_obj    // 约束对象
        )
    );
}
```

每个节点封装了：
- 该时刻的动力学方程 `f(x, u)`
- 该时刻的代价函数 `l(x, u)`
- 该时刻的约束 `c(x, u)`

#### 4.3.4 求解器初始化

```cpp
NewALILQR<6,2> solver(
    ilqr_node_list, // 节点列表（51 个节点）
    init_state,     // 初始状态 [0, 0, 0, 0, 10, 0]
    left_obs,       // 左侧障碍物（用于可视化或特定处理）
    right_obs       // 右侧障碍物
);
```

求解器内部会：
1. 初始化拉格朗日乘子 `λ = 0`
2. 初始化惩罚系数 `μ = 初始值`（通常 μ₀ = 1.0）
3. 生成初始轨迹猜测（通常使用 LQR 线性化初始化）

#### 4.3.5 优化执行

```cpp
solver.optimize(50, 100, 1e-3);
```

参数解释：
- `max_outer_iter = 50`: 外层最大迭代 50 次
- `max_inner_iter = 100`: 每次外层迭代中，内层 iLQR 最多迭代 100 次
- `max_violation = 1e-3`: 约束违反容忍度（当违反量 < 1e-3 时认为约束满足）

**优化过程伪代码**：

```
初始化: λ = 0, μ = μ₀
For outer_iter = 1 to 50:
    // 内层 iLQR 优化
    For inner_iter = 1 to 100:
        // 1. 计算增广代价函数的导数
        For k = 0 to N-1:
            计算 f_x, f_u  (动力学雅可比)
            计算 l_x, l_u, l_xx, l_uu, l_xu  (代价函数导数)
            加入约束惩罚项: l += λ·max(0,c) + (μ/2)·max(0,c)²

        // 2. Backward Pass
        V_x[N], V_xx[N] = 终端代价导数
        For k = N-1 downto 0:
            Q_x  = l_x  + f_xᵀ V_x[k+1]
            Q_u  = l_u  + f_uᵀ V_x[k+1]
            Q_xx = l_xx + f_xᵀ V_xx[k+1] f_x
            Q_uu = l_uu + f_uᵀ V_xx[k+1] f_u
            Q_xu = l_xu + f_xᵀ V_xx[k+1] f_u

            K[k] = -Q_uu⁻¹ Q_xu
            k[k] = -Q_uu⁻¹ Q_u

            V_x[k]  = Q_x  - Kᵀ Q_uu K
            V_xx[k] = Q_xx - Kᵀ Q_uu K

        // 3. Forward Pass (线搜索)
        For α in [1.0, 0.5, 0.25, 0.125, ...]:
            x_new[0] = init_state
            cost_new = 0
            For k = 0 to N-1:
                u_new[k] = u_old[k] + α·k[k] + K[k]·(x_new[k] - x_old[k])
                x_new[k+1] = f(x_new[k], u_new[k])
                cost_new += l(x_new[k], u_new[k])

            If cost_new < cost_old:
                接受新轨迹
                break

        If 收敛 (代价变化 < 阈值):
            break

    // 4. 更新拉格朗日乘子
    For k = 0 to N-1:
        violation[k] = max(0, c(x[k], u[k]))
        λ[k] = max(0, λ[k] + μ * violation[k])

    // 5. 检查约束满足度
    total_violation = ||violation||₂
    If total_violation < 1e-3:
        收敛，退出

    // 6. 增加惩罚系数
    μ = 10 * μ
```

#### 4.3.6 结果输出

```cpp
// 输出控制序列 (2 × 50)
for(int i = 0; i < num_points - 1; ++i) {
    std::cout << "u_result " << solver.get_u_list().col(i).transpose() << std::endl;
}

// 输出状态轨迹 (6 × 50)
for(int i = 0; i < num_points - 1; ++i) {
    std::cout << "x_result " << solver.get_x_list().col(i).transpose() << std::endl;
}
```

注意：只输出前 49 个时间步（k=0 到 k=48），因为第 50 个时间步是终端状态，没有对应的控制输入。

### 4.4 测试二：二次约束优化

#### 4.4.1 约束矩阵构建

**约束维度**：
```cpp
constexpr int constraint_dim = 5;  // 5 个约束
```

**约束列表**：
1. 约束 0：圆形障碍物（二次约束）
2. 约束 1：`δ_rate ≤ 0.2`
3. 约束 2：`a_rate ≤ 1`
4. 约束 3：`δ_rate ≥ -0.2`
5. 约束 4：`a_rate ≥ -1`

**系数矩阵初始化**：

```cpp
Eigen::Matrix<double, 5, 6> A;  // 状态的一次项系数 (5×6)
Eigen::Matrix<double, 5, 2> B;  // 控制的一次项系数 (5×2)
Eigen::Matrix<double, 5, 1> C;  // 常数项 (5×1)
std::array<Eigen::Matrix<double, 6, 6>, 5> Q;  // 状态的二次项系数（5 个 6×6 矩阵）
```

#### 4.4.2 圆形障碍物约束

**障碍物参数**：
- 中心位置：`(xₒ, yₒ) = (20, 12)` 米
- 半径：`r = 4` 米

**调用生成函数**：
```cpp
auto ans = GenerateCycleEquations(20.0, 12.0, 4.0, 6);
Q[0] = std::get<0>(ans);            // 6×6 矩阵
A.row(0) = std::get<1>(ans);        // 1×6 向量
C(0, 0) = std::get<2>(ans).value(); // 标量
```

**生成的系数**：

```
Q[0] = [-1  0  0  0  0  0]
       [ 0 -1  0  0  0  0]
       [ 0  0  0  0  0  0]
       [ 0  0  0  0  0  0]
       [ 0  0  0  0  0  0]
       [ 0  0  0  0  0  0]

A[0, :] = [40, 24, 0, 0, 0, 0]

C[0] = 16 - 400 - 144 = -528
```

**约束评估**：

对于状态 `x = [x, y, θ, δ, v, a]ᵀ`，约束函数为：

```
c₀(x) = xᵀ Q[0] x + A[0,:]·x + C[0]
      = -x² - y² + 40x + 24y - 528
```

- 当车辆位置 `(x, y)` 在圆内时，`c₀ > 0`（违反约束）
- 当车辆位置在圆外时，`c₀ ≤ 0`（满足约束）

#### 4.4.3 控制约束设置

```cpp
B << 0, 0,      // 约束 0: 障碍物（不涉及控制）
     1, 0,      // 约束 1: δ_rate
     0, 1,      // 约束 2: a_rate
    -1, 0,      // 约束 3: -δ_rate
     0, -1;     // 约束 4: -a_rate

C << 0,         // 约束 0: 障碍物常数项（已设置）
    -0.2,       // 约束 1: δ_rate - 0.2 ≤ 0
    -1,         // 约束 2: a_rate - 1 ≤ 0
    -0.2,       // 约束 3: -δ_rate - 0.2 ≤ 0
    -1;         // 约束 4: -a_rate - 1 ≤ 0
```

#### 4.4.4 二次约束对象创建

```cpp
QuadraticConstraints<6, 2, 5> quad_constraints(Q, A, B, C);
```

该对象封装了 5 个二次约束的系数，提供以下接口：
- `evaluate(x, u)`: 评估约束值 `c(x, u)`
- `jacobian(x, u)`: 计算约束的雅可比矩阵
- `hessian(x, u)`: 计算约束的海森矩阵（用于二阶导数）

#### 4.4.5 优化执行

```cpp
NewALILQR<6,2> q_solver(q_ilqr_node_list, init_state);
q_solver.optimize(30, 100, 1e-3);
```

与测试一的区别：
- **外层迭代次数**：30 次（相对较少）
- **约束类型**：二次约束（更灵活，但计算稍复杂）
- **预期行为**：轨迹应该绕过位于 `(20, 12)` 的圆形障碍物

#### 4.4.6 预期结果分析

**参考轨迹通过障碍物区域**：

在 `t ≈ 2秒` 附近：
- 参考位置：`x ≈ 20m, y ≈ 9.93m`
- 障碍物中心：`(20, 12)`
- 距离：`√((20-20)² + (9.93-12)²) ≈ 2.07m < 4m`

**优化器的调整策略**：

由于参考轨迹会穿过障碍物，优化器必须偏离参考轨迹：
1. **y 方向调整**：向下偏移（y 减小）或向上偏移（y 增大）
2. **代价平衡**：
   - 偏离参考轨迹增加跟踪代价 `(x-xᵣₑ f)ᵀQ(x-xᵣₑ f)`
   - 满足障碍物约束增加控制代价（需要更大的转向）
3. **最优解**：找到代价和约束满足度的平衡

**可能的输出特征**：

- **状态轨迹**：在障碍物附近，y 坐标会明显偏离参考值
- **控制输入**：接近障碍物时，`δ_rate` 会有较大变化（急转向）
- **约束满足**：最终 `c₀(x, y) ≤ 0`（车辆不进入圆形区域）

---

## 5. 算法实现细节

### 5.1 动力学线性化

在 `NewBicycleNode` 中实现的 `dynamics_jacobian()` 方法计算雅可比矩阵：

```
f_x = ∂f/∂x,  f_u = ∂f/∂u
```

对于自行车模型：

```
f_x = [∂ẋ/∂x   ∂ẋ/∂y   ∂ẋ/∂θ         ∂ẋ/∂δ   ∂ẋ/∂v   ∂ẋ/∂a  ]
      [∂ẏ/∂x   ∂ẏ/∂y   ∂ẏ/∂θ         ∂ẏ/∂δ   ∂ẏ/∂v   ∂ẏ/∂a  ]
      [∂θ̇/∂x   ∂θ̇/∂y   ∂θ̇/∂θ         ∂θ̇/∂δ   ∂θ̇/∂v   ∂θ̇/∂a  ]
      [∂δ̇/∂x   ∂δ̇/∂y   ∂δ̇/∂θ         ∂δ̇/∂δ   ∂δ̇/∂v   ∂δ̇/∂a  ]
      [∂v̇/∂x   ∂v̇/∂y   ∂v̇/∂θ         ∂v̇/∂δ   ∂v̇/∂v   ∂v̇/∂a  ]
      [∂ȧ/∂x   ∂ȧ/∂y   ∂ȧ/∂θ         ∂ȧ/∂δ   ∂ȧ/∂v   ∂ȧ/∂a  ]

    = [0  0  -v·sin(θ)  0           cos(θ)  0]
      [0  0   v·cos(θ)  0           sin(θ)  0]
      [0  0   0          v·sec²(δ)/L  tan(δ)/L  0]
      [0  0   0          0           0       0]
      [0  0   0          0           0       1]
      [0  0   0          0           0       0]
```

```
f_u = [0        0      ]
      [0        0      ]
      [0        0      ]
      [1        0      ]
      [0        0      ]
      [0        1      ]
```

### 5.2 代价函数导数

对于二次代价函数：

```
l(x, u) = (x - xᵣₑ f)ᵀ Q (x - xᵣₑ f) + uᵀ R u
```

一阶导数：

```
l_x = 2Q(x - xᵣₑ f)
l_u = 2Ru
```

二阶导数（海森矩阵）：

```
l_xx = 2Q
l_uu = 2R
l_xu = 0  (交叉项为零，因为 l 是 x 和 u 的可分离函数)
```

### 5.3 约束导数

对于二次约束 `c(x, u) = xᵀQx + Aᵀx + Bᵀu + C`：

```
∂c/∂x = 2Qx + A
∂c/∂u = B
∂²c/∂x² = 2Q
∂²c/∂u² = 0
∂²c/∂x∂u = 0
```

这些导数会被加入到增广代价函数的导数中：

```
l_x ← l_x + λ·∂c/∂x + μ·max(0,c)·∂c/∂x
l_xx ← l_xx + λ·∂²c/∂x² + μ·(∂c/∂x)(∂c/∂x)ᵀ
...
```

### 5.4 角度归一化

由于 θ 和 δ 是角度，需要特殊处理周期性：

```cpp
// 将角度归一化到 [-π, π]
double normalize_angle(double angle) {
    while (angle > M_PI) angle -= 2 * M_PI;
    while (angle < -M_PI) angle += 2 * M_PI;
    return angle;
}
```

在状态更新和误差计算时都需要调用此函数。

### 5.5 并行线搜索

代码使用并行计算同时评估多个步长：

```cpp
// 伪代码
std::vector<double> alphas = {1.0, 0.5, 0.25, 0.125, ...};
std::vector<double> costs(alphas.size());

#pragma omp parallel for
for (int i = 0; i < alphas.size(); ++i) {
    costs[i] = evaluate_trajectory(alphas[i]);
}

int best_idx = std::min_element(costs.begin(), costs.end()) - costs.begin();
double best_alpha = alphas[best_idx];
```

这显著提高了线搜索效率。

---

## 6. 参数调优指南

### 6.1 代价权重矩阵

**调整原则**：

| 参数 | 增大影响 | 减小影响 | 推荐范围 |
|------|----------|----------|----------|
| `Q[0,0]` (x) | 更严格的 x 跟踪 | 允许 x 偏差 | 10 - 1000 |
| `Q[1,1]` (y) | 更严格的 y 跟踪 | 允许 y 偏差 | 10 - 1000 |
| `Q[2,2]` (θ) | 更严格的航向跟踪 | 允许航向偏差 | 100 - 5000 |
| `Q[3,3]` (δ) | 惩罚转向角变化 | 自由转向 | 0.001 - 1 |
| `Q[4,4]` (v) | 更严格的速度跟踪 | 允许速度变化 | 1 - 100 |
| `Q[5,5]` (a) | 惩罚加速度 | 允许加速度变化 | 1 - 100 |
| `R[0,0]` (δ_rate) | 转向更平滑 | 允许急转向 | 10 - 1000 |
| `R[1,1]` (a_rate) | 加速更平滑 | 允许急加速 | 10 - 1000 |

**调试技巧**：

1. **跟踪性能不佳**：增大 Q 对应元素
2. **轨迹抖动**：增大 R
3. **约束违反**：减小某些 Q 元素，给优化器更多自由度
4. **收敛慢**：适当减小 Q 和 R，降低问题难度

### 6.2 优化器参数

**外层迭代次数** (`max_outer_iter`)：
- 典型值：20 - 50
- 约束简单（如盒式约束）：较少迭代（20-30）
- 约束复杂（如障碍物避障）：较多迭代（30-50）

**内层迭代次数** (`max_inner_iter`)：
- 典型值：50 - 200
- 初始猜测较好：较少迭代（50-100）
- 初始猜测较差：较多迭代（100-200）

**约束容忍度** (`max_violation`)：
- 典型值：1e-4 - 1e-2
- 严格约束：1e-4
- 宽松约束：1e-2

**惩罚系数初值和增长率**：
- 初值 `μ₀`：1.0 - 10.0
- 增长率 `β`：5 - 10
- 过大的 μ 会导致数值问题，过小则约束满足慢

### 6.3 时间离散化

**时间步长** (`dt`)：
- 典型值：0.05 - 0.2 秒
- 较小 dt（0.05s）：更高精度，但计算量大
- 较大 dt（0.2s）：计算快，但精度降低
- 权衡：速度越快，dt 应越小

**轨迹点数** (`num_points`)：
- 典型值：30 - 100
- 取决于总时长和 dt：`num_points = T / dt`
- 过多点会增加计算负担

### 6.4 约束设计

**盒式约束**：
- 设置合理的上下界，避免过紧
- 控制约束应符合车辆物理限制

**二次约束（障碍物）**：
- 障碍物半径应考虑车辆尺寸（加安全余量）
- 如果优化器难以找到可行解，考虑：
  1. 放宽其他约束
  2. 调整参考轨迹
  3. 增加外层迭代次数

---

## 附录

### A. 符号表

| 符号 | 含义 | 维度 |
|------|------|------|
| `x` | 状态向量 | 6 × 1 |
| `u` | 控制向量 | 2 × 1 |
| `N` | 时间步数 | 标量 |
| `Q` | 状态代价权重矩阵 | 6 × 6 |
| `R` | 控制代价权重矩阵 | 2 × 2 |
| `f(x,u)` | 动力学函数 | 6 × 1 |
| `l(x,u)` | 阶段代价函数 | 标量 |
| `c(x,u)` | 约束函数 | m × 1 |
| `λ` | 拉格朗日乘子 | m × 1 |
| `μ` | 惩罚系数 | 标量 |
| `K` | 反馈增益矩阵 | 2 × 6 |
| `k` | 前馈控制项 | 2 × 1 |
| `V(x)` | 值函数 | 标量 |

### B. 参考文献

1. **iLQR 算法**:
   - Tassa, Y., et al. (2012). "Synthesis and stabilization of complex behaviors through online trajectory optimization."

2. **增广拉格朗日法**:
   - Bertsekas, D. P. (2014). "Constrained Optimization and Lagrange Multiplier Methods."

3. **自行车模型**:
   - Rajamani, R. (2011). "Vehicle Dynamics and Control." Springer.

### C. 扩展阅读

- `docs/test_pybind_详细解析.md`: Python 绑定的详细说明
- `docs/C++测试文件对比_signal_vs_standard.md`: 不同测试文件的对比
- `CLAUDE.md`: 项目整体架构说明

---

**文档版本**: 1.0
**创建时间**: 2025-11-03
**适用代码版本**: test_new_al_ilqr.cc (当前版本)
