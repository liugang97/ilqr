# iLQR 快速开始指南

## 目录

1. [环境配置](#环境配置)
2. [安装步骤](#安装步骤)
3. [Python 快速示例](#python-快速示例)
4. [C++ 编译与使用](#c-编译与使用)
5. [测试用例运行](#测试用例运行)
6. [常见问题](#常见问题)

---

## 环境配置

### 系统要求

- **操作系统**: Linux (推荐 Ubuntu 18.04+) / macOS
- **Python**: 3.7+
- **C++ 编译器**: GCC 7.0+ 或 Clang 6.0+
- **构建工具**: Bazel 3.0+ (仅 C++ 部分需要)

### Python 依赖

```bash
# 核心依赖
numpy>=1.19.0
matplotlib>=3.3.0

# 可选依赖(用于可视化)
scipy>=1.5.0
```

### C++ 依赖

- **Eigen3**: 线性代数库 (版本 3.3+)
- **pybind11**: Python 绑定库
- **Bazel**: 构建系统

---

## 安装步骤

### 方法 1: 仅使用 Python 版本

```bash
# 1. 克隆仓库
cd /path/to/your/workspace
git clone <repository_url>
cd ilqr/cilqr

# 2. 安装 Python 依赖
pip install numpy matplotlib scipy

# 3. 运行测试验证
python test.py
```

### 方法 2: 编译 C++ 高性能版本

```bash
# 1. 安装 Bazel (如果未安装)
# Ubuntu/Debian
sudo apt install bazel

# macOS
brew install bazel

# 2. 进入 C++ 目录
cd ilqr/cilqr/al_ilqr_cpp

# 3. 构建所有目标
bazel build //...

# 4. 构建 Python 绑定
bazel build //:ilqr_pybind

# 5. 将生成的 .so 文件复制到 Python 可访问路径
cp bazel-bin/ilqr_pybind.so ../

# 6. 测试 Python 绑定
cd ..
python test_pybind.py
```

---

## Python 快速示例

### 示例 1: 横向自行车模型轨迹跟踪

```python
import numpy as np
import matplotlib.pyplot as plt
from lat_bicycle_node import LatBicycleKinematicNode
from ilqr import ILQR

# ========== 参数设置 ==========
v = 10.0          # 纵向速度 (m/s)
dt = 0.1          # 时间步长 (s)
L = 2.5           # 轴距 (m)
num_points = 30   # 时间步数

# ========== 生成 S 型参考轨迹 ==========
def generate_s_shape_goal(v, dt, num_points):
    goals = []
    for i in range(num_points + 1):
        t = i * dt
        x = v * t
        y = 50 * np.sin(0.1 * t)
        theta = np.arctan2(50 * 0.1 * np.cos(0.1 * t), v)
        curvature = (50 * 0.1 * 0.1) / ((v**2 + (50*0.1*np.cos(0.1*t))**2)**1.5)
        delta = np.arctan(curvature * L)
        goals.append([x, y, theta, delta])
    return goals

goal_list = generate_s_shape_goal(v, dt, num_points)

# ========== 定义代价函数权重 ==========
Q = np.diag([1e-3, 1e-1, 1e1, 1e-9])  # 状态权重 [x, y, θ, δ]
R = np.array([[50.0]])                # 控制权重 [δ̇]

# ========== 定义约束 ==========
state_bounds = np.array([
    [-1000, -1000, -2*np.pi, -0.5],   # 下界
    [1000, 1000, 2*np.pi, 0.5]        # 上界
])
control_bounds = np.array([[-0.1], [0.1]])  # 转角速率限制

# ========== 创建 iLQR 节点 ==========
ilqr_nodes = [
    LatBicycleKinematicNode(
        L=L, dt=dt, v=v,
        state_bounds=state_bounds,
        control_bounds=control_bounds,
        goal=goal, Q=Q, R=R
    )
    for goal in goal_list
]

# ========== 创建求解器 ==========
ilqr_solver = ILQR(ilqr_nodes)

# ========== 设置初始状态 ==========
ilqr_nodes[0].state = np.array([0, 0, 0, 0])

# ========== 优化求解 ==========
x_init, u_init, x_opt, u_opt = ilqr_solver.optimize()

# ========== 可视化结果 ==========
plt.figure(figsize=(12, 5))

# 轨迹对比
plt.subplot(1, 2, 1)
plt.plot(x_init[:, 0], x_init[:, 1], 'g--', label='初始轨迹', linewidth=2)
plt.plot(x_opt[:, 0], x_opt[:, 1], 'b-', label='优化轨迹', linewidth=2)
plt.plot([g[0] for g in goal_list], [g[1] for g in goal_list], 'r.', label='参考点', markersize=8)
plt.xlabel('X (m)')
plt.ylabel('Y (m)')
plt.title('轨迹对比')
plt.legend()
plt.grid(True)

# 控制输入
plt.subplot(1, 2, 2)
plt.plot(u_opt, 'b-', linewidth=2)
plt.xlabel('时间步')
plt.ylabel('前轮转角速率 (rad/s)')
plt.title('控制输入')
plt.grid(True)

plt.tight_layout()
plt.show()
```

**运行结果**:
- 车辆从起点 `(0, 0)` 出发,跟踪 S 型参考轨迹
- 优化后的轨迹平滑且接近参考点
- 控制输入满足约束 `|δ̇| ≤ 0.1 rad/s`

**代码位置**: `cilqr/test.py`

---

### 示例 2: 使用盒式约束

```python
from box_constrains import BoxConstraint
from fast_bicycle_node import FastBicycleNode
from fast_ilqr import FastILQR

# ========== 定义严格约束 ==========
state_min = np.array([-100, -10, -np.pi, -0.4])
state_max = np.array([100, 10, np.pi, 0.4])
control_min = np.array([-0.05])
control_max = np.array([0.05])

# 创建盒式约束对象
box_constraint = BoxConstraint(state_min, state_max, control_min, control_max)

# ========== 创建节点(带约束) ==========
ilqr_nodes = [
    FastBicycleNode(
        L=L, dt=dt, v=v,
        constraints_obj=box_constraint,
        goal=goal, Q=Q, R=R
    )
    for goal in goal_list
]

# ========== 求解 ==========
ilqr_solver = FastILQR(ilqr_nodes)
ilqr_nodes[0].state = np.array([0, 0, 0, 0])
x_init, u_init, x_opt, u_opt = ilqr_solver.optimize()

# ========== 验证约束满足 ==========
print("状态范围检查:")
print(f"  x: [{x_opt[:, 0].min():.2f}, {x_opt[:, 0].max():.2f}]")
print(f"  y: [{x_opt[:, 1].min():.2f}, {x_opt[:, 1].max():.2f}]")
print(f"  δ: [{x_opt[:, 3].min():.4f}, {x_opt[:, 3].max():.4f}]")
print(f"控制范围: [{u_opt.min():.4f}, {u_opt.max():.4f}]")
```

**代码位置**: `cilqr/test_fast_full.py`

---

## C++ 编译与使用

### 编译 C++ 测试程序

```bash
cd cilqr/al_ilqr_cpp

# 编译并运行横向模型测试
bazel run //:test_lat_al_ilqr

# 编译并运行完整模型测试
bazel run //:test_new_al_ilqr

# 编译并运行动态约束测试
bazel run //:test_dynamic_constraints_ilqr
```

### Python 调用 C++ 求解器

```python
from cilqr.al_ilqr_cpp.ilqr_pybind import (
    NewALILQR6_2,           # 6 维状态, 2 维控制
    NewBicycleNode6_2,      # 自行车模型节点
    BoxConstraints6_2       # 盒式约束
)
import numpy as np

# ========== 参数设置 ==========
horizon = 30
state_dim = 6
control_dim = 2

# ========== 创建 C++ 节点 ==========
nodes = []
for i in range(horizon + 1):
    node = NewBicycleNode6_2()
    # 设置目标、权重等参数
    node.set_goal(goal_list[i])
    node.set_Q(Q_matrix)
    node.set_R(R_matrix)
    nodes.append(node)

# ========== 创建求解器 ==========
init_state = np.array([0, 0, 0, 0, 10, 0])  # [x, y, θ, δ, v, a]
solver = NewALILQR6_2(nodes, init_state)

# ========== 优化求解 ==========
solver.optimize(
    max_outer_iter=20,
    max_inner_iter=10,
    max_violation=1e-3
)

# ========== 提取结果 ==========
x_opt = solver.get_x_list()  # (6, horizon+1)
u_opt = solver.get_u_list()  # (2, horizon)
K_list = solver.get_K()      # 反馈增益列表
```

**性能对比**:
```
Python 版本: ~500 ms (30 步, 10 次迭代)
C++ 版本:    ~15 ms (30 步, 10 次迭代)
加速比:      33x
```

**代码位置**: `cilqr/test_pybind.py`, `cilqr/test_lat_bicycle_pybind.py`

---

## 测试用例运行

### Python 测试

```bash
cd cilqr

# 测试 1: 横向自行车模型 (基础 iLQR)
python test.py

# 测试 2: 完整动力学模型
python test_full.py

# 测试 3: 快速实现版本
python test_fast_full.py

# 测试 4: Python 绑定测试
python test_pybind.py

# 测试 5: 矩形障碍物避让
python test_rectangle_obs_pybind.py

# 测试 6: 横向模型 Python 绑定
python test_lat_bicycle_pybind.py
```

### C++ 测试

```bash
cd cilqr/al_ilqr_cpp

# 测试 1: 新版 AL-iLQR
bazel run //:test_new_al_ilqr

# 测试 2: 横向模型
bazel run //:test_lat_al_ilqr

# 测试 3: 动态约束
bazel run //:test_dynamic_constraints_ilqr

# 测试 4: 单次优化测试
bazel run //:test_new_al_ilqr_signal
```

### 预期输出

成功运行后,你应该看到:

```
old cost 50.242...
violation 0.0234...
violation 0.00156...
violation 0.000089...
Final cost: 12.345...
Optimization converged!
```

并显示轨迹对比图。

---

## 常见问题

### Q1: 导入模块失败

**问题**:
```python
ModuleNotFoundError: No module named 'lat_bicycle_node'
```

**解决方案**:
```bash
# 确保在 cilqr 目录下运行
cd /path/to/ilqr/cilqr
python test.py

# 或添加到 PYTHONPATH
export PYTHONPATH=/path/to/ilqr/cilqr:$PYTHONPATH
python test.py
```

---

### Q2: C++ 编译失败

**问题**:
```
fatal error: Eigen/Dense: No such file or directory
```

**解决方案**:

检查 `WORKSPACE` 文件中 Eigen 路径配置:

```python
# al_ilqr_cpp/WORKSPACE
new_local_repository(
    name = "eigen",
    path = "/usr/include/eigen3",  # 修改为你的 Eigen 路径
    build_file_content = """
cc_library(
    name = "eigen",
    hdrs = glob(["**"]),
    includes = ["."],
    visibility = ["//visibility:public"],
)
"""
)
```

查找 Eigen 安装路径:
```bash
# Ubuntu/Debian
dpkg -L libeigen3-dev | grep Eigen/Dense

# macOS
brew info eigen
```

---

### Q3: 优化不收敛

**问题**: 代价函数振荡或约束违反度不降低

**解决方案**:

1. **调整权重矩阵**:
   ```python
   # 增大状态权重,减小控制权重
   Q = np.diag([1e-2, 1e0, 1e2, 1e-8])  # 更强的跟踪
   R = np.array([[10.0]])                # 更宽松的控制
   ```

2. **放松约束**:
   ```python
   # 使用更宽松的约束边界
   state_bounds = np.array([
       [-1000, -1000, -2*np.pi, -1.0],
       [1000, 1000, 2*np.pi, 1.0]
   ])
   ```

3. **调整 ALM 参数**:
   ```python
   # 在 ilqr.py 中修改
   if violation >= 1e-1:
       self.update_mu(4.0)  # 从 8.0 改为 4.0,更温和
   ```

4. **改善初始猜测**:
   ```python
   # 使用更接近可行解的初始状态
   ilqr_nodes[0].state = np.array([0, 0.1, 0.01, 0])
   ```

---

### Q4: Python 绑定找不到 .so 文件

**问题**:
```python
ImportError: ilqr_pybind.so: cannot open shared object file
```

**解决方案**:

```bash
# 1. 找到生成的 .so 文件
find cilqr/al_ilqr_cpp/bazel-bin -name "*.so"

# 2. 复制到 cilqr 目录
cp cilqr/al_ilqr_cpp/bazel-bin/ilqr_pybind.so cilqr/

# 3. 或创建软链接
ln -s $(pwd)/cilqr/al_ilqr_cpp/bazel-bin/ilqr_pybind.so cilqr/

# 4. 验证导入
cd cilqr
python -c "from ilqr_pybind import NewALILQR6_2; print('OK')"
```

---

### Q5: 角度跳变问题

**问题**: 航向角 θ 在优化过程中出现跳变 (±2π)

**解决方案**:

确保所有角度都经过归一化:

```python
def normalize_angle(angle):
    return (angle + np.pi) % (2 * np.pi) - np.pi

# 在 dynamics 函数中
state_next[2] = normalize_angle(state_next[2])  # θ
state_next[3] = normalize_angle(state_next[3])  # δ
```

**实现位置**: `cilqr/lat_bicycle_node.py:23-30`

---

### Q6: 内存泄漏 (C++)

**问题**: 长时间运行 C++ 版本后内存占用增加

**解决方案**:

使用智能指针管理节点:

```cpp
// 正确方式
std::vector<std::shared_ptr<NewILQRNode<6, 2>>> nodes;
for (int i = 0; i <= horizon; ++i) {
    nodes.push_back(std::make_shared<NewBicycleNode6_2>(...));
}

// 避免裸指针
// NewILQRNode<6, 2>* node = new NewBicycleNode6_2(...);  // 不推荐
```

---

## 性能调优建议

### 1. 选择合适的时间步长

```python
# 平衡精度和效率
dt = 0.1   # 低速场景 (< 15 m/s)
dt = 0.05  # 高速场景 (> 20 m/s)
```

### 2. 优化迭代次数

```python
# 实时应用
ilqr_solver.optimize(max_iters=5, tol=1e-6)

# 离线规划
ilqr_solver.optimize(max_iters=50, tol=1e-9)
```

### 3. 使用 C++ 加速

对于实时性要求高的场景,优先使用 C++ 实现:

| 场景 | 推荐实现 | 预期频率 |
|------|---------|---------|
| 原型开发 | Python | 1-5 Hz |
| 在线 MPC | C++ | 10-50 Hz |
| 离线优化 | Python | 不限 |

---

## 下一步

- 阅读 [算法原理文档](01_算法原理.md) 深入理解算法
- 查看 [API 参考文档](03_API参考.md) 了解所有接口
- 尝试修改代价函数和约束,适配自己的应用场景
- 探索 `viewer/` 目录下的可视化工具

---

**最后更新**: 2025-10-11
**维护者**: iLQR Solver Team
