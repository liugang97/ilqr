# C++ 测试与 Python 测试对比分析

## 概述

`test_new_al_ilqr.cc` (C++) 和 `test_pybind.py` (Python) 这两个文件的**核心作用相同**，都是测试 iLQR 求解器的功能，但在**实现细节和测试场景上有所不同**。

---

## 相似之处

### 1. 核心功能完全相同

两个文件都执行以下测试流程：

```
1. 生成 S 形参考轨迹
2. 配置代价函数权重 (Q, R)
3. 第一次优化：使用基础约束
4. 第二次优化：添加障碍物约束
5. 输出结果
```

### 2. 算法参数一致

| 参数 | C++ | Python | 说明 |
|------|-----|--------|------|
| 期望速度 v | 10 m/s | 10 m/s | ✓ |
| 时间步长 dt | 0.1 s | 0.1 s | ✓ |
| 车辆轴距 L | 3.0 m | 3.0 m | ✓ |
| 正则化系数 k | 0.001 | 0.001 | ✓ |
| Q 矩阵 | diag([100, 100, 1000, 0.001, 1, 1]) | 相同 | ✓ |
| R 矩阵 | diag([100, 100]) | 相同 | ✓ |
| 状态边界 | [-1000, 1000, ...] | 相同 | ✓ |
| 控制边界 | [-0.2, 0.2], [-1, 1] | 相同 | ✓ |

### 3. 数学模型一致

- 都使用 **6 维状态向量**: `[x, y, θ, δ, v, a]`
- 都使用 **2 维控制向量**: `[δ̇, ȧ]`
- 都使用 **相同的 S 形轨迹生成公式**:
  ```
  x(t) = v·t
  y(t) = 50·sin(0.1·t)
  ```

---

## 关键差异

### 1. 轨迹时域长度不同

| 文件 | num_points | 总时长 | 总距离 |
|------|------------|--------|--------|
| **C++** | 50 | 5.0 秒 | 50 米 |
| **Python** | 30 | 3.0 秒 | 30 米 |

**影响**：
- C++ 测试更长的轨迹规划能力
- Python 测试计算更快，适合演示

### 2. 障碍物类型和参数不同

#### C++ 版本：

**第一次优化**：使用**矩形障碍物** (动态线性约束)

```cpp
// 第 78-83 行
Eigen::Matrix<double, 2, 4> left_car;
left_car << 32, 32, 28, 28,   // x 坐标
            14, 16, 16, 14;    // y 坐标
```

矩形的 4 个顶点：
- (32, 14), (32, 16), (28, 16), (28, 14)
- 宽度: 4m, 高度: 2m
- 位置: x ∈ [28, 32], y ∈ [14, 16]

**第二次优化**：使用**圆形障碍物** (二次约束)

```cpp
// 第 114 行
auto ans = GenerateCycleEquations(20.0, 12, 4.0, 6);
```
- 圆心: (20, 12)
- 半径: 4m

#### Python 版本：

**第一次优化**：**仅使用盒式约束** (无障碍物)

**第二次优化**：使用**圆形障碍物** (二次约束)

```python
# 第 308-311 行
circle_x = 30
circle_y = 11
circle_r = 6
```
- 圆心: (30, 11)
- 半径: 6m

### 3. 障碍物位置对比

根据参考轨迹 `y(t) = 50·sin(0.1·t)`：

| x 坐标 | 时间 t | y 坐标 (参考轨迹) |
|--------|--------|-------------------|
| 20 | 2.0s | 50·sin(0.2) ≈ 9.9m |
| 28-32 | 2.8-3.2s | 50·sin(0.28-0.32) ≈ 13.8-15.7m |
| 30 | 3.0s | 50·sin(0.3) ≈ 14.8m |

**分析**：
- C++ 的矩形障碍物 (28-32, 14-16) 在轨迹中段，会与参考路径重叠
- C++ 的圆形障碍物 (20, 12) 在轨迹前段
- Python 的圆形障碍物 (30, 11) 在轨迹中段，与参考路径距离 ≈ 3.8m

### 4. 优化参数差异

| 参数 | C++ (第1次) | C++ (第2次) | Python (两次) |
|------|-------------|-------------|---------------|
| max_outer_iter | 50 | 30 | 50 |
| max_inner_iter | 100 | 100 | 100 |
| max_violation | 1e-3 | 1e-3 | 1e-4 |

Python 的约束容忍度更严格 (1e-4 vs 1e-3)。

### 5. 输出方式不同

**C++ 版本** (第 91-141 行):
```cpp
std::cout << "u_result " << solver.get_u_list().col(i).transpose() << std::endl;
std::cout << "x_result " << solver.get_x_list().col(i).transpose() << std::endl;
```
- 输出文本到控制台
- 适合调试和验证数值结果

**Python 版本** (第 370-417 行):
```python
plt.plot(plot_x, plot_y, label='...', c='b')
plt.show()
```
- 使用 matplotlib 可视化
- 绘制三条轨迹对比图
- 适合演示和教学

---

## 测试侧重点分析

### C++ 版本侧重点

1. **多种约束类型测试**：
   - 动态线性约束 (矩形障碍物)
   - 二次约束 (圆形障碍物)

2. **数值验证**：
   - 直接输出数值结果
   - 便于单元测试和回归测试

3. **性能测试**：
   - 更长的时域 (50 个点)
   - 测试算法在复杂场景下的表现

### Python 版本侧重点

1. **教学演示**：
   - 可视化对比
   - 清晰的注释和分段说明

2. **Python 绑定验证**：
   - 测试 pybind11 接口是否正常工作
   - 验证 Python 调用 C++ 的完整流程

3. **直观展示**：
   - 图形化展示三条轨迹的差异
   - 直观理解约束的作用

---

## 二次约束配置差异

### C++ 版本 (第 99-121 行)

```cpp
constexpr int constraint_dim = 5;
B << 0, 0,     // 第1个约束：圆形障碍物
     1, 0,     // 第2个约束：u[0] 上界
     0, 1,     // 第3个约束：u[1] 上界
    -1, 0,     // 第4个约束：u[0] 下界
     0, -1;    // 第5个约束：u[1] 下界
C << 0, -0.2, -1, -0.2, -1;
```

### Python 版本 (第 293-305 行)

```python
B = np.array([
    [0, 0],   # 第1个约束：圆形障碍物
    [1, 0],   # 第2个约束
    [0, 1],
    [-1, 0],
    [0, -1]
])
C = np.array([[0], [-0.4], [-1], [-0.4], [-1]])
```

**注意**：约束 2-5 的 C 参数不同 (-0.2 vs -0.4)，但这些约束与盒式约束矛盾，实际不起作用。

---

## 使用场景建议

### 使用 C++ 版本 (`test_new_al_ilqr.cc`) 当你需要：

✓ 性能基准测试
✓ 回归测试（CI/CD）
✓ 数值精度验证
✓ 测试矩形障碍物场景
✓ 命令行快速测试

### 使用 Python 版本 (`test_pybind.py`) 当你需要：

✓ 演示和教学
✓ 快速可视化结果
✓ 验证 Python API
✓ 参数调优（交互式）
✓ 生成论文/报告图表

---

## 总结

| 对比项 | 结论 |
|--------|------|
| **核心算法** | ✅ 完全相同 |
| **数学模型** | ✅ 完全相同 |
| **参数设置** | ⚠️ 基本相同，细节有差异 |
| **测试场景** | ❌ 不同（轨迹长度、障碍物类型） |
| **输出方式** | ❌ 不同（文本 vs 可视化） |
| **使用目的** | ⚠️ 重叠但侧重点不同 |

**结论**：两个文件**作用基本相同**（都是测试 iLQR 求解器），但它们是**互补**的关系：
- C++ 版本：更适合开发和调试
- Python 版本：更适合展示和教学

建议两个版本都保留，用于不同场景。
