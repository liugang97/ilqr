# iLQR 算法原理详解

## 目录

1. [概述](#概述)
2. [iLQR 基础理论](#ilqr-基础理论)
3. [增广拉格朗日法 (ALM)](#增广拉格朗日法-alm)
4. [算法流程](#算法流程)
5. [数学推导](#数学推导)
6. [车辆动力学模型](#车辆动力学模型)

---

## 概述

**iLQR (Iterative Linear Quadratic Regulator)** 是一种基于轨迹优化的非线性最优控制算法,广泛应用于机器人运动规划和自动驾驶领域。该算法通过在标称轨迹附近进行局部线性化,将非线性优化问题转化为一系列二次规划问题,从而高效求解。

### 核心特点

- **高效性**: 通过动态规划(Dynamic Programming)实现,时间复杂度为 O(N)
- **局部最优**: 在标称轨迹附近进行局部优化
- **约束处理**: 结合增广拉格朗日法处理状态和控制约束
- **实时性**: 适合车辆运动规划等实时应用场景

---

## iLQR 基础理论

### 1. 问题定义

考虑离散时间非线性动力系统:

```
x_{t+1} = f(x_t, u_t)
```

其中:
- `x_t ∈ ℝ^n`: 状态向量
- `u_t ∈ ℝ^m`: 控制输入
- `f(·)`: 非线性动力学函数

优化目标是最小化总代价:

```
J = Φ(x_N) + Σ_{t=0}^{N-1} L(x_t, u_t)
```

其中:
- `Φ(x_N)`: 终端代价
- `L(x_t, u_t)`: 阶段代价(通常为二次型)

### 2. 二次代价函数

在本实现中,阶段代价通常定义为:

```
L(x_t, u_t) = (x_t - x_goal)^T Q (x_t - x_goal) + u_t^T R u_t
```

其中:
- `Q ∈ ℝ^{n×n}`: 状态权重矩阵(半正定)
- `R ∈ ℝ^{m×m}`: 控制权重矩阵(正定)
- `x_goal`: 目标状态

### 3. 动力学线性化

在标称轨迹 `(x̄_t, ū_t)` 附近进行一阶泰勒展开:

```
x_{t+1} ≈ f(x̄_t, ū_t) + A_t(x_t - x̄_t) + B_t(u_t - ū_t)
```

其中雅可比矩阵为:

```
A_t = ∂f/∂x |_{x̄_t, ū_t}
B_t = ∂f/∂u |_{x̄_t, ū_t}
```

### 4. 代价函数二次近似

代价函数的二阶泰勒展开:

```
L(x_t, u_t) ≈ L̄_t + L_x δx_t + L_u δu_t
              + (1/2) δx_t^T L_{xx} δx_t
              + (1/2) δu_t^T L_{uu} δu_t
              + δx_t^T L_{xu} δu_t
```

其中:
- `δx_t = x_t - x̄_t`: 状态偏差
- `δu_t = u_t - ū_t`: 控制偏差
- `L_x, L_u`: 一阶导数(雅可比)
- `L_{xx}, L_{uu}, L_{xu}`: 二阶导数(海森矩阵)

---

## iLQR 算法核心:反向传播与前向传播

### 反向传播 (Backward Pass)

从终端时刻 `t = N` 开始向前递推,计算:

1. **Q 函数**:

```
Q_x = L_x + A_t^T V_x
Q_u = L_u + B_t^T V_x
Q_{xx} = L_{xx} + A_t^T V_{xx} A_t
Q_{uu} = L_{uu} + B_t^T V_{xx} B_t
Q_{ux} = L_{ux} + B_t^T V_{xx} A_t
```

2. **最优控制策略**:

```
K_t = -Q_{uu}^{-1} Q_{ux}  (反馈增益)
k_t = -Q_{uu}^{-1} Q_u     (前馈项)
```

3. **值函数更新**:

```
V_x = Q_x + K_t^T Q_{uu} k_t + K_t^T Q_u + Q_{ux}^T k_t
V_{xx} = Q_{xx} + K_t^T Q_{uu} K_t + K_t^T Q_{ux} + Q_{ux}^T K_t
```

**实现位置**: `cilqr/ilqr.py:58-100` (Python), `cilqr/al_ilqr_cpp/new_al_ilqr.h:143` (C++)

### 前向传播 (Forward Pass)

使用线搜索更新轨迹:

```
u_t^{new} = ū_t + α k_t + K_t (x_t^{new} - x̄_t)
x_{t+1}^{new} = f(x_t^{new}, u_t^{new})
```

其中 `α ∈ (0, 1]` 是步长参数,通过 Armijo 回溯线搜索确定:

- 初始 `α = 1.0`
- 若代价未减小,则 `α ← α/2`
- 重复直到代价下降或 `α < ε`

**实现位置**: `cilqr/ilqr.py:102-149`

---

## 增广拉格朗日法 (ALM)

### 1. 约束问题

考虑带不等式约束的优化问题:

```
minimize   J(x, u)
subject to c(x, u) ≤ 0
```

其中 `c: ℝ^n × ℝ^m → ℝ^p` 是约束函数。

### 2. 增广拉格朗日函数

```
L_A(x, u, λ, μ) = J(x, u) + λ^T c(x, u) + (μ/2) ||max(0, c(x,u))||^2
```

等价形式(投影):

```
L_A(x, u, λ, μ) = J(x, u) + (1/(2μ)) (||P(λ - μc)||^2 - ||λ||^2)
```

其中:
- `λ ∈ ℝ^p`: 拉格朗日乘子
- `μ > 0`: 惩罚因子
- `P(·) = min(·, 0)`: 投影到可行域

**实现位置**: `cilqr/constraints.py:59-65`

### 3. KKT 条件与投影

对于不等式约束,需要满足 KKT 条件:

```
λ_i ≥ 0
c_i(x, u) ≤ 0
λ_i c_i(x, u) = 0  (互补松弛)
```

投影函数确保 KKT 条件:

```
P(x) = { x,  if x < 0
       { 0,  if x ≥ 0
```

**实现位置**: `cilqr/constraints.py:47-54`

### 4. 参数更新策略

根据约束违反度 `v` 自适应更新:

```python
v = ||max(0, c(x,u))||_∞

if v < 1e-3:
    # 收敛,停止
elif 1e-3 ≤ v < 1e-1:
    # 更新拉格朗日乘子
    λ ← P(λ - μc)
else:
    # 增大惩罚因子
    μ ← 8μ
```

**实现位置**: `cilqr/ilqr.py:166-174`

### 5. 增广拉格朗日代价的导数

**一阶导数**(雅可比):

```
∂L_A/∂x = ∂J/∂x - (∂c/∂x)^T P(λ - μc)
∂L_A/∂u = ∂J/∂u - (∂c/∂u)^T P(λ - μc)
```

**二阶导数**(海森矩阵):

```
∂²L_A/∂x² = ∂²J/∂x² + μ (∂c/∂x)^T Π (∂c/∂x) - Σ P_i(λ-μc) ∂²c_i/∂x²
```

其中 `Π` 是投影雅可比矩阵的对角矩阵。

**实现位置**: `cilqr/constraints.py:67-104`

---

## 算法流程

### 主优化循环

```
初始化: x̄, ū, λ=0, μ=1

for outer_iter = 1 to max_outer_iter:
    for inner_iter = 1 to max_inner_iter:
        1. 反向传播: 计算 K, k
        2. 前向传播: 更新轨迹 x, u
        3. 检查收敛: |ΔJ| < tol

    4. 计算约束违反度 v
    5. if v < 1e-3: 收敛退出
       elif v < 1e-1: 更新 λ
       else: 增大 μ
```

**实现位置**: `cilqr/ilqr.py:151-175`

### 初始猜测生成

使用 LQR 在目标状态附近生成初始轨迹:

```python
def linearized_initial_guess():
    # 1. 反向计算 LQR 增益 K
    for t in reversed(range(horizon)):
        A, B = dynamics_jacobian(goal, 0)
        K = inv(R + B^T P B) B^T P A
        P = Q + A^T P (A - B K)

    # 2. 前向传播生成轨迹
    for t in range(horizon):
        u[t] = -K @ (x[t] - goal)
        x[t+1] = dynamics(x[t], u[t])

    return x, u
```

**实现位置**: `cilqr/ilqr.py:11-50`

---

## 数学推导

### 1. 动态规划原理

值函数定义:

```
V_t(x_t) = min_{u_t, ..., u_{N-1}} Σ_{k=t}^{N-1} L(x_k, u_k) + Φ(x_N)
```

贝尔曼方程:

```
V_t(x_t) = min_{u_t} { L(x_t, u_t) + V_{t+1}(f(x_t, u_t)) }
```

### 2. 二次近似

假设值函数为二次型:

```
V_t(x_t) ≈ V_t(x̄_t) + V_x^T δx_t + (1/2) δx_t^T V_{xx} δx_t
```

代入贝尔曼方程并求导,得最优控制:

```
u_t* = argmin_u { L(x_t, u) + V_{t+1}(f(x_t, u)) }
```

一阶必要条件:

```
0 = L_u + B_t^T (V_x + V_{xx} (A_t δx_t + B_t δu_t))
```

解得:

```
δu_t* = -(L_{uu} + B_t^T V_{xx} B_t)^{-1}
         × (L_u + B_t^T V_{xx} A_t δx_t + B_t^T V_x)
      = k_t + K_t δx_t
```

### 3. 正则化技术

为保证 `Q_{uu}` 正定,添加正则化项:

```
Q_{uu} ← Q_{uu} + ε I
```

其中 `ε = 1e-9` (默认值)。

**实现位置**: `cilqr/ilqr.py:92`

---

## 车辆动力学模型

### 1. 横向自行车运动学模型

**状态向量**: `x = [x, y, θ, δ]`
- `(x, y)`: 车辆质心位置
- `θ`: 航向角
- `δ`: 前轮转角

**控制输入**: `u = [δ̇]` (前轮转角速率)

**连续时间动力学**:

```
ẋ = v cos(θ)
ẏ = v sin(θ)
θ̇ = (v/L) tan(δ)
δ̇ = u
```

其中:
- `v`: 纵向速度(常数)
- `L`: 轴距

**离散化**: 使用 RK2 (二阶龙格-库塔)方法:

```python
k1 = f(x, u)
k2 = f(x + 0.5*dt*k1, u)
x_next = x + dt * k2
```

**实现位置**: `cilqr/lat_bicycle_node.py:32-56`

### 2. 完整自行车动力学模型

**状态向量**: `x = [x, y, θ, δ, v, a]`

额外考虑:
- `v`: 纵向速度(状态变量)
- `a`: 纵向加速度

**控制输入**: `u = [δ̇, j]`
- `δ̇`: 前轮转角速率
- `j`: 加加速度

**实现位置**: `cilqr/full_bicycle_dynamic_node.py`

### 3. 雅可比矩阵计算

通过符号推导获得解析雅可比:

```python
A = ∂f/∂x = [[∂f₁/∂x₁, ..., ∂f₁/∂xₙ],
              [...     , ..., ...     ],
              [∂fₙ/∂x₁, ..., ∂fₙ/∂xₙ]]

B = ∂f/∂u = [[∂f₁/∂u₁, ..., ∂f₁/∂uₘ],
              [...     , ..., ...     ],
              [∂fₙ/∂u₁, ..., ∂fₙ/∂uₘ]]
```

**实现位置**: `cilqr/lat_bicycle_node.py:58-91`

### 4. 角度归一化

所有角度状态归一化到 `(-π, π)`:

```python
def normalize_angle(angle):
    return (angle + π) % (2π) - π
```

**重要性**: 防止角度跳变导致的优化失败。

**实现位置**: `cilqr/lat_bicycle_node.py:23-30`

---

## 约束类型

### 1. 盒式约束 (Box Constraints)

状态和控制的上下界约束:

```
x_min ≤ x ≤ x_max
u_min ≤ u ≤ u_max
```

转化为线性不等式:

```
c(x, u) = [x - x_max; x_min - x; u - u_max; u_min - u] ≤ 0
```

**实现位置**: `cilqr/box_constrains.py`, `cilqr/al_ilqr_cpp/constraints/box_constraints.h`

### 2. 线性约束

一般形式:

```
A x + B u + C ≤ 0
```

**实现位置**: `cilqr/linear_constraints.py`

### 3. 二次约束 (Quadratic Constraints)

用于障碍物避让:

```
c_i(x) = (p - p_obs)^T Q (p - p_obs) - r² ≤ 0
```

其中:
- `p = (x, y)`: 车辆位置
- `p_obs`: 障碍物中心
- `r`: 安全半径

**实现位置**: `cilqr/al_ilqr_cpp/constraints/quadratic_constraints.h`

### 4. 动态约束

允许约束在不同时间步具有不同参数。

**实现位置**: `cilqr/al_ilqr_cpp/constraints/dynamic_linear_constraints.h`

---

## 数值稳定性技巧

### 1. 正则化

- 在 `Q_{uu}` 中添加小量避免奇异: `Q_{uu} + ε I`
- 海森矩阵正定化

### 2. 线搜索

- 使用回溯线搜索保证代价下降
- 最小步长 `α_min = 1e-8`

### 3. 惩罚因子调节

- 初始 `μ = 1.0`
- 根据违反度自适应增大(通常 8 倍)
- 避免过大的 `μ` 导致病态

### 4. 并行计算 (C++ 实现)

- 使用 Eigen 库向量化
- 编译选项: `-O3 -march=native -DEIGEN_VECTORIZE`
- 线搜索并行化

**实现位置**: `cilqr/al_ilqr_cpp/new_al_ilqr.h:137`

---

## 性能优化

### Python vs C++

| 维度 | Python | C++ (pybind11) |
|------|--------|----------------|
| 灵活性 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ |
| 速度 | ⭐⭐ | ⭐⭐⭐⭐⭐ |
| 调试 | 易 | 较难 |
| 适用场景 | 原型开发 | 生产部署 |

**加速比**: C++ 实现通常比 Python 快 10-50 倍。

### C++ 模板优化

编译时特化避免运行时开销:

```cpp
template<int state_dim, int control_dim>
class NewALILQR {
    using VectorState = Eigen::Matrix<double, state_dim, 1>;
    using MatrixA = Eigen::Matrix<double, state_dim, state_dim>;
    // ...
};
```

**实现位置**: `cilqr/al_ilqr_cpp/new_al_ilqr.h:16-27`

---

## 参考文献

1. **Tassa, Y., Erez, T., & Todorov, E. (2012)**. "Synthesis and stabilization of complex behaviors through online trajectory optimization." *IROS 2012*.

2. **Bertsekas, D. P. (1982)**. "Constrained Optimization and Lagrange Multiplier Methods." *Academic Press*.

3. **Li, W., & Todorov, E. (2004)**. "Iterative Linear Quadratic Regulator Design for Nonlinear Biological Movement Systems." *ICINCO 2004*.

4. **Nocedal, J., & Wright, S. J. (2006)**. "Numerical Optimization." *Springer*.

---

## 附录:符号表

| 符号 | 含义 | 维度 |
|------|------|------|
| `x_t` | 状态向量 | n × 1 |
| `u_t` | 控制向量 | m × 1 |
| `f(·)` | 动力学函数 | ℝⁿ × ℝᵐ → ℝⁿ |
| `A_t` | 状态雅可比 | n × n |
| `B_t` | 控制雅可比 | n × m |
| `Q` | 状态权重 | n × n |
| `R` | 控制权重 | m × m |
| `K_t` | 反馈增益 | m × n |
| `k_t` | 前馈项 | m × 1 |
| `V_x` | 值函数梯度 | n × 1 |
| `V_{xx}` | 值函数海森 | n × n |
| `λ` | 拉格朗日乘子 | p × 1 |
| `μ` | 惩罚因子 | 标量 |

---

**最后更新**: 2025-10-11
**作者**: iLQR Solver Team
