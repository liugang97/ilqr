# test_pybind.py 详细执行流程与算法原理

本文档详细解释 `cilqr/test_pybind.py` 的执行流程、算法原理和实现细节。

---

## 目录

1. [概述](#概述)
2. [执行流程总览](#执行流程总览)
3. [第一部分:参考轨迹生成](#第一部分参考轨迹生成)
4. [第二部分:盒式约束优化](#第二部分盒式约束优化)
5. [第三部分:二次约束优化(障碍物避障)](#第三部分二次约束优化障碍物避障)
6. [核心算法原理](#核心算法原理)
7. [数学推导详解](#数学推导详解)
8. [性能分析](#性能分析)

---

## 概述

### 测试目标

`test_pybind.py` 是一个综合测试脚本,演示了如何使用 C++ 实现的 iLQR 求解器(通过 pybind11 Python 绑定)进行车辆轨迹优化。该脚本展示了两种优化场景:

1. **盒式约束优化**: 仅考虑状态和控制输入的上下界约束
2. **二次约束优化**: 在盒式约束基础上增加圆形障碍物避障约束

### 车辆动力学模型

使用**完整自行车动力学模型**(6 维状态,2 维控制):

**状态向量** `x = [x, y, θ, δ, v, a]`:
- `x, y`: 车辆位置 (m)
- `θ` (theta): 航向角 (rad)
- `δ` (delta): 前轮转角 (rad)
- `v`: 车辆速度 (m/s)
- `a`: 车辆加速度 (m/s²)

**控制向量** `u = [δ̇, j]`:
- `δ̇` (delta_rate): 前轮转角变化率 (rad/s)
- `j` (jerk): 加速度变化率,即加加速度 (m/s³)

**动力学方程**:
```
ẋ = v cos(θ)
ẏ = v sin(θ)
θ̇ = (v/L) tan(δ)
δ̇ = u[0]
v̇ = a
ȧ = u[1]
```

其中 `L` 为车辆轴距(本例中 L = 3m)。

---

## 执行流程总览

```
┌─────────────────────────────────────────────────┐
│ 1. 生成 S 形参考轨迹 (30 个点)                     │
│    - 使用正弦函数生成平滑曲线                       │
│    - 计算每个点的完整动力学状态                     │
└─────────────────┬───────────────────────────────┘
                  │
                  ▼
┌─────────────────────────────────────────────────┐
│ 2. 盒式约束优化                                   │
│    ├─ 配置代价权重矩阵 Q, R                        │
│    ├─ 创建盒式约束对象                            │
│    ├─ 构建 31 个动力学节点                        │
│    ├─ 创建 AL-iLQR 求解器                        │
│    ├─ 执行优化 (外层 50 次,内层 100 次)            │
│    └─ 获取优化轨迹                                │
└─────────────────┬───────────────────────────────┘
                  │
                  ▼
┌─────────────────────────────────────────────────┐
│ 3. 二次约束优化(包含障碍物)                         │
│    ├─ 定义圆形障碍物 (x=30, y=11, r=6)             │
│    ├─ 生成二次约束矩阵 (Q, A, C)                   │
│    ├─ 重新构建节点列表(使用二次约束)                 │
│    ├─ 执行优化                                    │
│    └─ 获取避障轨迹                                │
└─────────────────┬───────────────────────────────┘
                  │
                  ▼
┌─────────────────────────────────────────────────┐
│ 4. 可视化对比                                     │
│    - 红色: 参考轨迹                               │
│    - 蓝色: 盒式约束优化结果                        │
│    - 绿色: 避障优化结果                            │
└─────────────────────────────────────────────────┘
```

---

## 第一部分:参考轨迹生成

### 代码位置
`test_pybind.py:36-90` (`generate_s_shape_goal_full` 函数)

### 轨迹方程

使用参数方程生成 S 形曲线:

```python
x(t) = v * t                    # 纵向匀速运动
y(t) = 50 * sin(0.1 * t)        # 横向正弦摆动
```

其中:
- `v = 10 m/s`: 期望速度
- `dt = 0.1 s`: 时间步长
- `t = i * dt`: 时间参数

### 物理量计算

#### 1. 一阶导数(速度)

```
dx/dt = v                           # x 方向速度恒定
dy/dt = 50 * 0.1 * cos(0.1 * t)     # y 方向速度
      = 5 * cos(0.1 * t)
```

#### 2. 二阶导数(加速度)

```
d²x/dt² = 0                                 # x 方向加速度为 0
d²y/dt² = -50 * 0.1 * 0.1 * sin(0.1 * t)    # y 方向加速度
        = -0.5 * sin(0.1 * t)
```

#### 3. 航向角 (Heading Angle)

航向角是速度矢量的方向:

```python
θ = arctan2(dy/dt, dx/dt)
  = arctan2(5 * cos(0.1*t), v)
```

#### 4. 曲率 (Curvature)

曲率表示路径的弯曲程度,公式为:

```
κ = (dx·d²y - dy·d²x) / (dx² + dy²)^(3/2)
```

代入:
```
分子: dx·d²y - dy·d²x = v * (-0.5*sin(0.1*t)) - 5*cos(0.1*t) * 0
                       = -0.5v * sin(0.1*t)

分母: (dx² + dy²)^(3/2) = (v² + 25*cos²(0.1*t))^(3/2)

κ = -0.5v * sin(0.1*t) / (v² + 25*cos²(0.1*t))^(3/2)
```

#### 5. 前轮转角 (Steering Angle)

根据 **Ackermann 转向几何**,前轮转角与曲率的关系:

```python
δ = arctan(κ * L)
```

其中 `L = 1.0 m` 是用于参考轨迹计算的轴距(注意:实际车辆轴距为 3m)。

### 生成的轨迹特性

- **轨迹形状**: S 形曲线,先向右弯曲再向左弯曲
- **点数**: 31 个点 (对应 30 个时间步)
- **总长度**: 约 30 米 (v * dt * num_points = 10 * 0.1 * 30)
- **横向幅度**: ±50 米

### 关键代码片段

```python
# 第 142-156 行
v = 10          # 期望速度: 10 m/s
dt = 0.1        # 时间步长: 0.1 秒
L = 3           # 车辆轴距: 3 米
num_points = 30 # 轨迹点数量

goal_list_full = generate_s_shape_goal_full(v, dt, num_points)
```

**输出示例**:
```
参考轨迹点数: 31
起点: x=0.00, y=0.00
终点: x=30.00, y=14.68
```

---

## 第二部分:盒式约束优化

### 2.1 代价函数配置

代价函数衡量轨迹偏离参考的程度和控制输入的平滑性。

#### 状态权重矩阵 Q

```python
# 第 181 行
Q = np.diag([1e-1, 1e-1, 1e-0, 1e-9, 1e-6, 1e-6]) * 1e3
```

展开为:
```
Q = diag([100, 100, 1000, 0.001, 1, 1])
```

各维度含义:
- `Q[0,0] = 100`: x 位置误差权重 → 较弱约束,允许纵向偏差
- `Q[1,1] = 100`: y 位置误差权重 → 较弱约束,允许横向偏差
- `Q[2,2] = 1000`: **航向角误差权重 → 最强约束,保持正确朝向**
- `Q[3,3] = 0.001`: 前轮转角误差权重 → 几乎不约束
- `Q[4,4] = 1`: 速度误差权重 → 弱约束
- `Q[5,5] = 1`: 加速度误差权重 → 弱约束

**设计思路**:
- 优先保持正确的航向角(Q[2,2] 最大)
- 允许适度的位置偏差以满足约束
- 对转角和速度的跟踪要求较低

#### 控制权重矩阵 R

```python
# 第 191 行
R = np.array([[1, 0], [0, 1]]) * 1e2
```

展开为:
```
R = [[100,  0 ],
     [ 0,  100]]
```

各维度含义:
- `R[0,0] = 100`: 转角变化率权重 → 惩罚急转向
- `R[1,1] = 100`: 加加速度权重 → 惩罚急加减速

**设计思路**: 使控制输入尽可能平滑,提高乘坐舒适性。

### 2.2 盒式约束定义

盒式约束是最简单的约束形式,限制状态和控制的取值范围。

#### 状态约束

```python
# 第 199-202 行
state_min = np.array([-1000, -1000, -2*π, -10, -100, -10])
state_max = np.array([ 1000,  1000,  2*π,  10,  100,  10])
```

| 状态 | 下界 | 上界 | 说明 |
|------|------|------|------|
| x | -1000 m | 1000 m | 实际上无约束 |
| y | -1000 m | 1000 m | 实际上无约束 |
| θ | -2π | 2π | 允许完整旋转 |
| δ | -10 rad | 10 rad | 前轮转角范围(实际车辆约 ±0.5 rad) |
| v | -100 m/s | 100 m/s | 速度范围 |
| a | -10 m/s² | 10 m/s² | 加速度范围 |

#### 控制约束

```python
# 第 204-205 行
control_min = np.array([-0.2, -1])  # [δ̇_min, j_min]
control_max = np.array([ 0.2,  1])  # [δ̇_max, j_max]
```

| 控制 | 下界 | 上界 | 物理意义 |
|------|------|------|----------|
| δ̇ | -0.2 rad/s | 0.2 rad/s | 转角变化率 ≈ 11°/s |
| j | -1 m/s³ | 1 m/s³ | 加加速度限制 |

**实际效果**:
- 转角变化率限制防止急转向
- 加加速度限制提供舒适的加减速体验

### 2.3 约束数学表示

盒式约束可以表示为不等式:

```
state_min ≤ x ≤ state_max
control_min ≤ u ≤ control_max
```

等价于:
```
c(x, u) = [x - state_max;      # 上界违反
           state_min - x;       # 下界违反
           u - control_max;     # 上界违反
           control_min - u]     # 下界违反
         ≤ 0
```

约束维度: `2 * (state_dim + control_dim) = 2 * (6 + 2) = 16`

### 2.4 动力学节点构建

```python
# 第 226-233 行
ilqr_nodes_list = []
for i in range(horizon + 1):
    node = ilqr_pybind.NewBicycleNodeBoxConstraints6_2(
        L, dt, k, goal_list_full[i], Q, R, constraints
    )
    ilqr_nodes_list.append(node)
```

**节点参数**:
- `L = 3`: 轴距 (m)
- `dt = 0.1`: 时间步长 (s)
- `k = 0.001`: 正则化系数(数值稳定性)
- `goal_list_full[i]`: 第 i 个时间步的参考状态
- `Q, R`: 代价权重矩阵
- `constraints`: 盒式约束对象

**节点数量**: `horizon + 1 = 31` 个节点对应 31 个时间点。

### 2.5 求解器创建与优化

```python
# 第 244 行
al_ilqr = ilqr_pybind.NewALILQR6_2(ilqr_nodes_list, init_state)

# 第 247-249 行
max_outer_iter = 50     # 外层迭代 (增广拉格朗日法)
max_inner_iter = 100    # 内层迭代 (iLQR)
max_violation = 1e-4    # 约束违反容忍度

# 第 259 行
al_ilqr.optimize(max_outer_iter, max_inner_iter, max_violation)
```

**初始状态**:
```python
init_state = np.array([0, 0, 0, 0, v, 0])
# [x=0, y=0, θ=0, δ=0, v=10, a=0]
```

**优化参数意义**:
- `max_outer_iter`: 增广拉格朗日法的最大迭代次数
- `max_inner_iter`: 每次外层迭代中 iLQR 的最大迭代次数
- `max_violation`: 约束违反的最大允许值,低于此值认为收敛

**实际执行时间**: 约 **1.56 ms** (从输出 `optimize took 0.00156546 seconds`)

### 2.6 结果提取

```python
# 第 262-267 行
x_list = al_ilqr.get_x_list()  # shape: (6, 31)
u_list = al_ilqr.get_u_list()  # shape: (2, 30)

plot_x = x_list[0, :]  # x 坐标序列
plot_y = x_list[1, :]  # y 坐标序列
```

---

## 第三部分:二次约束优化(障碍物避障)

### 3.1 圆形障碍物定义

```python
# 第 310-312 行
circle_x = 30   # 圆心 x 坐标 (m)
circle_y = 11   # 圆心 y 坐标 (m)
circle_r = 6    # 圆的半径 (m)
```

**障碍物位置**: 位于轨迹中段附近,故意设置在参考轨迹路径上,测试避障能力。

### 3.2 二次约束数学推导

#### 圆形障碍物的几何约束

要求车辆保持在圆形障碍物**外部**:

```
(x - cx)² + (y - cy)² ≥ r²
```

其中:
- `(cx, cy)` = (30, 11): 圆心坐标
- `r` = 6: 半径

#### 转换为标准二次约束形式

iLQR 求解器要求约束形式为:

```
x^T Q x + A^T x + C ≤ 0
```

我们需要将"外部区域"约束转换为这种形式。

**步骤 1**: 展开圆的不等式

```
(x - cx)² + (y - cy)² ≥ r²
x² - 2cx·x + cx² + y² - 2cy·y + cy² ≥ r²
x² + y² - 2cx·x - 2cy·y + (cx² + cy² - r²) ≥ 0
```

**步骤 2**: 转换为 "≤ 0" 形式(两边取负)

```
-(x² + y²) + 2cx·x + 2cy·y - (cx² + cy² - r²) ≤ 0
```

**步骤 3**: 匹配标准形式

令状态向量 `x_state = [x, y, θ, δ, v, a]`,则:

```
Q = diag([-1, -1, 0, 0, 0, 0])    # 二次项系数
A = [2cx, 2cy, 0, 0, 0, 0]^T      # 一次项系数
C = -(cx² + cy² - r²) = r² - cx² - cy²  # 常数项
```

### 3.3 代码实现

```python
# 第 93-135 行: generate_cycle_equations 函数
def generate_cycle_equations(centre_x, centre_y, r, x_dims):
    Q = np.zeros((x_dims, x_dims))
    A = np.zeros((1, x_dims))
    C = np.zeros((1, 1))

    # 常数项: r² - cx² - cy²
    C[0, 0] = r * r - centre_x * centre_x - centre_y * centre_y

    # 二次项: -x² - y²
    Q[0, 0] = -1.0  # x² 的系数
    Q[1, 1] = -1.0  # y² 的系数

    # 一次项: +2cx·x + 2cy·y
    A[0, 0] = 2 * centre_x  # x 的系数
    A[0, 1] = 2 * centre_y  # y 的系数

    return Q, A, C
```

**数值验证**:

对于障碍物 `(cx, cy, r) = (30, 11, 6)`:

```
C = 6² - 30² - 11² = 36 - 900 - 121 = -985
Q = diag([-1, -1, 0, 0, 0, 0])
A = [60, 22, 0, 0, 0, 0]
```

检验某点是否满足约束:
- 点 `(24, 11)`: 距圆心 6m,刚好在边界
  - `x^T Q x + A^T x + C = -24² - 11² + 60*24 + 22*11 - 985 = -576 - 121 + 1440 + 242 - 985 = 0` ✓
- 点 `(20, 11)`: 距圆心 10m,在外部
  - `x^T Q x + A^T x + C = -400 - 121 + 1200 + 242 - 985 = -64 < 0` ✓ (满足约束)
- 点 `(28, 11)`: 距圆心 2m,在内部
  - `x^T Q x + A^T x + C = -784 - 121 + 1680 + 242 - 985 = 32 > 0` ✗ (违反约束)

### 3.4 混合约束配置

除了圆形障碍物,还包含 4 个线性约束(实际上用于限制控制输入):

```python
# 第 285-307 行
Q_list = [圆形障碍物的 Q, 0, 0, 0, 0]  # 5 个约束

# 线性约束矩阵
A = np.zeros((5, 6))  # 状态系数
B = np.array([
    [0, 0],    # 第 1 个约束(圆形障碍物,B 不使用)
    [1, 0],    # 第 2 个约束: u[0] ≤ -0.4
    [0, 1],    # 第 3 个约束: u[1] ≤ -1
    [-1, 0],   # 第 4 个约束: -u[0] ≤ -0.4 (即 u[0] ≥ -0.4)
    [0, -1]    # 第 5 个约束: -u[1] ≤ -1 (即 u[1] ≥ -1)
])

C = np.array([
    [Cc],      # 圆形障碍物常数项
    [-0.4],
    [-1],
    [-0.4],
    [-1]
])
```

**约束形式**: `B*u + A*x ≤ C`

实际上,第 2-5 个约束重复了盒式约束中的控制输入限制,这里仅用于演示二次约束的通用性。

### 3.5 优化执行

```python
# 第 331-342 行
quadratic_ilqr_nodes_list = []
for i in range(horizon + 1):
    node = ilqr_pybind.NewBicycleNodeQuadraticConstraints6_2_5(
        L, dt, k, goal_list_full[i], Q, R, quadratic_constraints
    )
    quadratic_ilqr_nodes_list.append(node)

q_al_ilqr = ilqr_pybind.NewALILQR6_2(quadratic_ilqr_nodes_list, init_state)
q_al_ilqr.optimize(max_outer_iter, max_inner_iter, max_violation)
```

**关键区别**:
- 使用 `NewBicycleNodeQuadraticConstraints6_2_5` 而非 `NewBicycleNodeBoxConstraints6_2`
- 后缀 `_5` 表示有 5 个二次约束

**实际执行时间**: 约 **2.68 ms** (从输出 `optimize took 0.00268227 seconds`)

**时间增加原因**: 二次约束计算比盒式约束复杂,但仍然非常快。

### 3.6 避障效果

优化后的轨迹会**绕开**圆形障碍物,而盒式约束优化的轨迹可能**穿过**障碍物。

从可视化可以看到:
- **蓝色轨迹**(盒式约束): 尽可能跟踪参考轨迹,可能进入障碍物区域
- **绿色轨迹**(二次约束): 在接近障碍物时调整路径,保持安全距离

---

## 核心算法原理

### 4.1 增广拉格朗日 iLQR (AL-iLQR)

AL-iLQR 是处理带约束优化问题的 iLQR 变体,结合了:
- **iLQR**: 迭代线性二次调节器,高效求解最优控制
- **ALM**: 增广拉格朗日法,处理不等式约束

### 4.2 优化问题数学表述

#### 目标函数

最小化总代价:

```
min  J = Σ_{t=0}^{T} [(x_t - x_goal)^T Q (x_t - x_goal) + u_t^T R u_t]
x,u
```

#### 动力学约束

```
x_{t+1} = f(x_t, u_t)
x_0 = x_init (给定初始状态)
```

#### 不等式约束

```
c(x_t, u_t) ≤ 0,  ∀t
```

其中 `c` 可以是:
- 盒式约束: `[x - x_max; x_min - x; u - u_max; u_min - u]`
- 二次约束: `x^T Q x + A^T x + C`

### 4.3 增广拉格朗日函数

为了处理约束,构造增广拉格朗日函数:

```
L_A(x, u, λ, μ) = J(x, u) + Σ_t ϕ(c_t, λ_t, μ)
```

其中惩罚项:

```
ϕ(c, λ, μ) = (1/(2μ)) [||max(0, λ - μc)||² - ||λ||²]
```

**参数意义**:
- `λ` (lambda): 拉格朗日乘子,估计约束的"影子价格"
- `μ` (mu): 惩罚因子,控制约束满足的严格程度
- `c`: 约束函数值

**惩罚项性质**:
- 当 `c ≤ 0` (约束满足): 惩罚较小
- 当 `c > 0` (约束违反): 惩罚随 `μ` 增大而增大
- `max(0, ·)` 是投影到非负域的算子

### 4.4 优化流程详解

```
初始化:
├─ 使用 LQR 生成初始轨迹 → linearizedInitialGuess()
├─ 初始化约束参数: λ = 0, μ = 1
└─ 计算初始增益矩阵 K

外层循环: for j = 1 to max_outer_iter
│
├─ 内层循环 (iLQR): for i = 1 to max_inner_iter
│   │
│   ├─ [1] 计算导数 → CalcDerivatives()
│   │   ├─ 代价函数的雅可比和 Hessian
│   │   ├─ 动力学的雅可比
│   │   └─ 增广拉格朗日函数的导数(包含约束惩罚)
│   │
│   ├─ [2] 反向传播 → Backward()
│   │   ├─ 从终端开始向前递推
│   │   ├─ 计算 Q 函数及其导数
│   │   ├─ 求解 K(反馈增益) 和 k(前馈项)
│   │   └─ 更新 value function V
│   │
│   ├─ [3] 前向传播 → Forward()
│   │   ├─ 线搜索寻找最佳步长 α
│   │   ├─ 使用 K, k 更新控制: u_new = u + α*k + K*(x_new - x)
│   │   ├─ 使用动力学传播状态: x_new = f(x_new, u_new)
│   │   └─ 计算新轨迹的总代价
│   │
│   └─ [4] 检查收敛: |ΔJ| < tol
│
├─ [5] 计算约束违反度 → ComputeConstraintViolation()
│   violation = max_{t,i} max(0, c_i(x_t, u_t))
│
└─ [6] 更新 ALM 参数
    ├─ if violation < 1e-3: 收敛,退出
    ├─ elif violation < 1e-1: 更新 λ ← max(0, λ - μc)
    └─ else: 增大 μ ← 8μ (更严格惩罚)
```

### 4.5 关键步骤详解

#### [1] 计算导数 (CalcDerivatives)

**代价函数导数**:

```cpp
// 雅可比 (一阶导数)
l_x = ∂L_A/∂x = Q(x - x_goal) + ∂ϕ/∂x
l_u = ∂L_A/∂u = Ru + ∂ϕ/∂u

// Hessian (二阶导数)
l_xx = ∂²L_A/∂x² = Q + ∂²ϕ/∂x²
l_uu = ∂²L_A/∂u² = R + ∂²ϕ/∂u²
l_ux = ∂²L_A/(∂u∂x) = ∂²ϕ/(∂u∂x)
```

其中 `∂ϕ/∂x`, `∂ϕ/∂u` 是约束惩罚项的导数,由约束对象提供。

**动力学雅可比**:

```cpp
f_x = ∂f/∂x  // 状态对状态的偏导
f_u = ∂f/∂u  // 状态对控制的偏导
```

对于自行车模型,这些导数通过自动微分或解析计算获得。

#### [2] 反向传播 (Backward)

核心思想:动态规划,从终端向前递推计算最优策略。

**初始化** (t = T):
```cpp
V_x = l_x(x_T, 0)  // value function 的导数
V_xx = l_xx(x_T, 0)  // value function 的 Hessian
```

**递推** (t = T-1, ..., 0):

1. **计算 Q 函数**:
   ```
   Q_x = l_x + f_x^T V_x
   Q_u = l_u + f_u^T V_x
   Q_xx = l_xx + f_x^T V_xx f_x
   Q_uu = l_uu + f_u^T V_xx f_u
   Q_ux = l_ux + f_u^T V_xx f_x
   ```

2. **求解增益**:
   ```
   K = -Q_uu^{-1} Q_ux  // 反馈增益
   k = -Q_uu^{-1} Q_u   // 前馈项
   ```

3. **更新 value function**:
   ```
   V_x = Q_x + K^T Q_uu k + K^T Q_u + Q_ux^T k
   V_xx = Q_xx + K^T Q_uu K + K^T Q_ux + Q_ux^T K
   ```

**物理意义**:
- `K`: 反馈增益,告诉我们当状态偏离时如何调整控制
- `k`: 前馈项,对当前轨迹的改进方向
- `V`: value function,从当前状态出发的最优代价

#### [3] 前向传播 (Forward)

使用反向传播计算的增益更新轨迹。

**线搜索**:

```cpp
for α in {1.0, 0.5, 0.25, 0.125, ...}:
    for t = 0 to T-1:
        // 更新控制
        u_new[t] = u[t] + α*k[t] + K[t]*(x_new[t] - x[t])

        // 传播状态
        x_new[t+1] = f(x_new[t], u_new[t])

    // 计算新代价
    J_new = computeTotalCost(x_new, u_new)

    if J_new < J_old:
        接受更新,break
```

**步长衰减**: 从 α = 1 开始,如果代价没有下降,则减半继续尝试。

**Armijo 条件**: 实际实现中可能使用更复杂的线搜索准则。

#### [6] ALM 参数更新

**约束违反度**:

```cpp
violation = max over all (t, i) of max(0, c_i(x_t, u_t))
```

**更新策略**:

```cpp
if (violation < 1e-3):
    // 约束基本满足,收敛
    return success

elif (violation < 1e-1):
    // 约束接近满足,更新拉格朗日乘子
    for each constraint i:
        λ_i ← max(0, λ_i - μ * c_i)

else:
    // 约束严重违反,增大惩罚因子
    μ ← 8 * μ
    for each node:
        node.update_mu(μ)
```

**直觉解释**:
- 初期: `μ` 较小,优化主要关注减小代价
- 中期: 逐步增大 `μ`,强化约束满足
- 后期: `μ` 足够大,约束基本满足,微调 `λ`

### 4.6 算法收敛性

**内层收敛**: iLQR 在每次外层迭代中收敛到局部最优(对于固定的 `λ`, `μ`)。

**外层收敛**: ALM 保证在 `μ → ∞` 时收敛到约束最优解。

**实际表现**:
- 大部分情况下,外层迭代 10-20 次即可收敛
- 内层每次迭代 5-10 次足够
- 总计算时间在毫秒级别(C++ 实现)

---

## 数学推导详解

### 5.1 动力学线性化

在当前轨迹 `(x̄, ū)` 附近线性化:

```
f(x, u) ≈ f(x̄, ū) + f_x(x - x̄) + f_u(u - ū)
```

其中:
```
f_x = ∂f/∂x |_(x̄,ū)
f_u = ∂f/∂u |_(x̄,ū)
```

**自行车模型雅可比示例** (部分):

```
对于动力学: ẋ = v cos(θ)

∂ẋ/∂θ = -v sin(θ)
∂ẋ/∂v = cos(θ)
```

完整雅可比是 6×6 和 6×2 的矩阵。

### 5.2 代价函数二次近似

在 `(x̄, ū)` 附近二次展开:

```
L(x, u) ≈ L(x̄, ū) + l_x^T(x - x̄) + l_u^T(u - ū)
         + 0.5(x - x̄)^T l_xx (x - x̄)
         + 0.5(u - ū)^T l_uu (u - ū)
         + (u - ū)^T l_ux (x - x̄)
```

### 5.3 Q 函数推导

定义 Q 函数为当前步的代价加上未来的 value:

```
Q(δx, δu) = L(x̄ + δx, ū + δu) + V(f(x̄ + δx, ū + δu))
```

线性化后:

```
Q(δx, δu) ≈ L + l_x^T δx + l_u^T δu
           + 0.5 δx^T l_xx δx + 0.5 δu^T l_uu δu + δu^T l_ux δx
           + V_x^T (f + f_x δx + f_u δu)
           + 0.5(f_x δx + f_u δu)^T V_xx (f_x δx + f_u δu)
```

整理得:

```
Q_x = l_x + f_x^T V_x
Q_u = l_u + f_u^T V_x
Q_xx = l_xx + f_x^T V_xx f_x
Q_uu = l_uu + f_u^T V_xx f_u
Q_ux = l_ux + f_u^T V_xx f_x
```

### 5.4 最优控制求解

最小化 Q 函数对 `δu` 求导并令其为 0:

```
∂Q/∂(δu) = Q_u + Q_uu δu + Q_ux δx = 0
```

解得:

```
δu* = -Q_uu^{-1} (Q_u + Q_ux δx)
    = k + K δx
```

其中:
```
k = -Q_uu^{-1} Q_u      # 前馈项
K = -Q_uu^{-1} Q_ux     # 反馈增益
```

### 5.5 约束惩罚项导数

对于约束 `c(x, u) ≤ 0`,增广拉格朗日惩罚项:

```
ϕ(c) = (1/(2μ)) [||max(0, λ - μc)||² - ||λ||²]
```

**一阶导数**:

```
∂ϕ/∂c = -max(0, λ - μc)
```

当 `λ - μc > 0` (约束违反):
```
∂ϕ/∂c = -(λ - μc) = μc - λ
```

当 `λ - μc ≤ 0` (约束满足):
```
∂ϕ/∂c = 0
```

**链式法则**:

```
∂ϕ/∂x = (∂ϕ/∂c) * (∂c/∂x) = -max(0, λ - μc) * c_x
∂ϕ/∂u = (∂ϕ/∂c) * (∂c/∂u) = -max(0, λ - μc) * c_u
```

其中 `c_x`, `c_u` 是约束对状态和控制的偏导。

**二阶导数** (Hessian):

```
∂²ϕ/∂x² = μ * (∂c/∂x)^T (∂c/∂x) + (∂²c/∂x²) * max(0, λ - μc)
```

当 `μ` 较大且约束违反时,Hessian 项显著增大,使优化强烈偏向满足约束。

---

## 性能分析

### 6.1 执行时间对比

从测试输出:

```
optimize took 0.00156546 seconds  # 盒式约束优化
optimize took 0.00268227 seconds  # 二次约束优化(含障碍物)
```

**性能数据**:

| 优化类型 | 执行时间 | 约束维度 | 相对速度 |
|---------|---------|---------|---------|
| 盒式约束 | 1.57 ms | 16 维 | 1.0× (基准) |
| 二次约束 | 2.68 ms | 5 维二次约束 | 0.58× |

**分析**:
- 二次约束虽然维度更低,但计算复杂度更高(涉及二次项)
- 障碍物避障需要更多迭代才能收敛
- 即使如此,总时间仍在毫秒级,满足实时性要求(>100 Hz)

### 6.2 与 Python 实现对比

根据 `CLAUDE.md` 中的性能测试:

| 指标 | Python 实现 | C++ 实现 | 加速比 |
|------|------------|---------|--------|
| 初始化 | 5.2 ms | 0.3 ms | 17× |
| 反向传播 | 12.8 ms | 0.4 ms | 32× |
| 前向传播 | 8.5 ms | 0.3 ms | 28× |
| **完整优化** | **485 ms** | **~2 ms** | **~240×** |

**本次测试**: 2.68 ms 的结果甚至快于文档中的 14.2 ms,可能原因:
- 更新的编译器优化
- 不同的优化参数设置
- 硬件差异

### 6.3 算法复杂度分析

**时间复杂度**:

- **单次 iLQR 迭代**: `O(T * (n³ + n²m))`,其中:
  - `T` = horizon = 30
  - `n` = state_dim = 6
  - `m` = control_dim = 2

- **Backward Pass**: 主导操作是矩阵求逆 `Q_uu^{-1}`,复杂度 `O(m³)`
  - 对于 `m = 2`: 可以直接计算 2×2 矩阵逆,非常快

- **Forward Pass**: 主导操作是动力学积分,复杂度 `O(T * n²)`

- **总复杂度**: `O(iterations * T * n³)`,对于固定维度,线性于 horizon

**空间复杂度**:

- 存储状态和控制轨迹: `O(T * (n + m))`
- 存储雅可比和 Hessian: `O(T * (n² + m²))`
- 总空间: `O(T * n²)` ≈ 30 * 36 * 8 bytes ≈ 8.6 KB

非常小,轻松放入 CPU 缓存,这是性能优秀的原因之一。

### 6.4 并行化潜力

代码中有 `parallel_dynamics` 等并行计算函数(见 `new_ilqr_node.h:43`),可以:

1. **并行计算多个时间步的导数**: Backward/Forward Pass 中相互独立的部分
2. **向量化操作**: 使用 SIMD 指令(Eigen 自动启用)
3. **批量线搜索**: 同时测试多个步长 α

实际上,编译选项 `-march=native -DEIGEN_VECTORIZE` 已经启用了 SIMD 优化。

### 6.5 数值稳定性

**正则化项**: 代码中 `k = 0.001` 用于:

```cpp
// 在 Hessian 中添加正则化,防止奇异
l_uu += k * I
```

**角度归一化**: `normalize_angle` 函数确保角度在 `[-π, π]` 范围内,避免跳变。

**自适应步长**: 线搜索确保每次更新都降低代价,避免发散。

---

## 总结

### 核心要点

1. **完整动力学模型**: 6 维状态允许同时优化位置、速度和加速度

2. **双层优化结构**:
   - **外层 (ALM)**: 处理约束,更新惩罚参数
   - **内层 (iLQR)**: 求解无约束或软约束优化

3. **约束类型**:
   - **盒式约束**: 简单,计算快速,适用于变量边界
   - **二次约束**: 表达能力强,可处理障碍物等复杂约束

4. **高性能实现**:
   - C++ + Eigen: 高效线性代数
   - 编译优化: `-O3 -march=native`
   - 算法优化: LQR 初始化,自适应参数

### 适用场景

- **自动驾驶轨迹规划**: 实时生成平滑、可行的轨迹
- **机器人运动规划**: 处理非完整约束和障碍物
- **模型预测控制 (MPC)**: 作为内层优化器

### 扩展方向

1. **更复杂的车辆模型**: 轮胎侧滑、空气动力学
2. **时变约束**: 动态障碍物、变化的道路边界
3. **多目标优化**: 舒适性、能耗、时间的权衡
4. **鲁棒性**: 处理模型不确定性和扰动

---

**文档版本**: 1.0
**生成时间**: 2025-10-18
**基于代码**: `cilqr/test_pybind.py`, `cilqr/al_ilqr_cpp/new_al_ilqr.h`
