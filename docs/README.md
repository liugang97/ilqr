# iLQR æ±‚è§£å™¨æ–‡æ¡£ä¸­å¿ƒ

æ¬¢è¿æ¥åˆ° iLQR æ±‚è§£å™¨çš„å®Œæ•´æ–‡æ¡£! æœ¬æ–‡æ¡£ç³»ç»Ÿå°†å¸®åŠ©ä½ å¿«é€Ÿä¸Šæ‰‹å¹¶æ·±å…¥ç†è§£è¿™ä¸ªé«˜æ€§èƒ½çš„è½¨è¿¹ä¼˜åŒ–æ¡†æ¶ã€‚

---

## ğŸ“š æ–‡æ¡£å¯¼èˆª

### æ–°æ‰‹å…¥é—¨

1. **[é¡¹ç›®æ¦‚è§ˆ](00_é¡¹ç›®æ¦‚è§ˆ.md)** â­ æ¨èé¦–è¯»
   - é¡¹ç›®ç®€ä»‹å’Œæ ¸å¿ƒç‰¹æ€§
   - é¡¹ç›®ç»“æ„å’Œæ¨¡å—è¯´æ˜
   - æŠ€æœ¯æ ˆå’Œæ€§èƒ½å¯¹æ¯”
   - åº”ç”¨åœºæ™¯å’Œæ‰©å±•æŒ‡å—

2. **[å¿«é€Ÿå¼€å§‹æŒ‡å—](02_å¿«é€Ÿå¼€å§‹æŒ‡å—.md)** âš¡ åŠ¨æ‰‹å®è·µ
   - ç¯å¢ƒé…ç½®å’Œå®‰è£…æ­¥éª¤
   - Python å¿«é€Ÿç¤ºä¾‹
   - C++ ç¼–è¯‘ä¸ä½¿ç”¨
   - å¸¸è§é—®é¢˜è§£ç­”

### æ·±å…¥å­¦ä¹ 

3. **[ç®—æ³•åŸç†](01_ç®—æ³•åŸç†.md)** ğŸ§  ç†è®ºåŸºç¡€
   - iLQR åŸºç¡€ç†è®º
   - å¢å¹¿æ‹‰æ ¼æœ—æ—¥æ³•(ALM)
   - æ•°å­¦æ¨å¯¼è¯¦è§£
   - è½¦è¾†åŠ¨åŠ›å­¦æ¨¡å‹
   - çº¦æŸå¤„ç†æ–¹æ³•

4. **[API å‚è€ƒ](03_APIå‚è€ƒ.md)** ğŸ“– å®Œæ•´æ‰‹å†Œ
   - Python API å®Œæ•´æ–‡æ¡£
   - C++ API æ¨¡æ¿ç±»è¯´æ˜
   - Python ç»‘å®šä½¿ç”¨æŒ‡å—
   - æ‰€æœ‰ç±»å’Œæ–¹æ³•è¯¦è§£

---

## ğŸš€ å¿«é€Ÿå¼€å§‹

### 10 åˆ†é’Ÿä¸Šæ‰‹

```python
# 1. å¯¼å…¥å¿…è¦æ¨¡å—
import numpy as np
from lat_bicycle_node import LatBicycleKinematicNode
from ilqr import ILQR

# 2. ç”Ÿæˆå‚è€ƒè½¨è¿¹ (S å‹æ›²çº¿)
def generate_s_curve(v=10, dt=0.1, N=30):
    goals = []
    for i in range(N + 1):
        t = i * dt
        x = v * t
        y = 50 * np.sin(0.1 * t)
        theta = np.arctan2(5 * np.cos(0.1 * t), v)
        delta = 0  # ç®€åŒ–å¤„ç†
        goals.append([x, y, theta, delta])
    return goals

goals = generate_s_curve()

# 3. åˆ›å»º iLQR èŠ‚ç‚¹
Q = np.diag([1e-3, 1e-1, 1e1, 1e-9])  # çŠ¶æ€æƒé‡
R = np.array([[50.0]])                # æ§åˆ¶æƒé‡

nodes = [
    LatBicycleKinematicNode(
        L=2.5, dt=0.1, v=10.0,
        state_bounds=np.array([[-1000, -10, -2*np.pi, -0.5],
                               [1000, 10, 2*np.pi, 0.5]]),
        control_bounds=np.array([[-0.1], [0.1]]),
        goal=g, Q=Q, R=R
    )
    for g in goals
]

# 4. æ±‚è§£ä¼˜åŒ–é—®é¢˜
solver = ILQR(nodes)
solver.ilqr_nodes[0].state = np.array([0, 0, 0, 0])
x_init, u_init, x_opt, u_opt = solver.optimize()

# 5. å¯è§†åŒ–ç»“æœ
import matplotlib.pyplot as plt
plt.plot(x_opt[:, 0], x_opt[:, 1], 'b-', label='ä¼˜åŒ–è½¨è¿¹')
plt.plot([g[0] for g in goals], [g[1] for g in goals], 'r.', label='å‚è€ƒç‚¹')
plt.legend()
plt.show()
```

**å®Œæ•´ç¤ºä¾‹**: è§ `cilqr/test.py`

---

## ğŸ“Š æ ¸å¿ƒç®—æ³•ä¸€è§ˆ

### iLQR ç®—æ³•æµç¨‹

```
åˆå§‹åŒ–
  â†“
ç”Ÿæˆåˆå§‹è½¨è¿¹ (LQR)
  â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ å¤–å±‚å¾ªç¯ (çº¦æŸå¤„ç†)      â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚ å†…å±‚å¾ªç¯ (iLQR)     â”‚ â”‚
â”‚ â”‚  - åå‘ä¼ æ’­         â”‚ â”‚
â”‚ â”‚  - å‰å‘ä¼ æ’­         â”‚ â”‚
â”‚ â”‚  - æ£€æŸ¥æ”¶æ•›         â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚   â†“                     â”‚
â”‚ æ›´æ–°çº¦æŸå‚æ•° (Î», Î¼)     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  â†“
è¿”å›æœ€ä¼˜è½¨è¿¹
```

### å…³é”®å…¬å¼

**åå‘ä¼ æ’­**:
```
K_t = -Q_{uu}^{-1} Q_{ux}
k_t = -Q_{uu}^{-1} Q_u
```

**å‰å‘ä¼ æ’­**:
```
u_t = Å«_t + Î± k_t + K_t (x_t - xÌ„_t)
```

**å¢å¹¿æ‹‰æ ¼æœ—æ—¥ä»£ä»·**:
```
L_A = J(x,u) + (1/(2Î¼))(||P(Î» - Î¼c)||Â² - ||Î»||Â²)
```

**è¯¦ç»†æ¨å¯¼**: è§ [ç®—æ³•åŸç†æ–‡æ¡£](01_ç®—æ³•åŸç†.md)

---

## ğŸ¯ å…¸å‹åº”ç”¨åœºæ™¯

### 1. è‡ªåŠ¨é©¾é©¶è½¨è¿¹è§„åˆ’

```python
# åœºæ™¯: è½¦é“ä¿æŒ + é¿è®©é™æ€éšœç¢ç‰©
from box_constrains import BoxConstraint

# å®šä¹‰è½¦é“è¾¹ç•Œçº¦æŸ
state_min = np.array([-100, -3.5, -np.pi/4, -0.5])  # y â‰¥ -3.5m (å³è½¦é“çº¿)
state_max = np.array([100, 3.5, np.pi/4, 0.5])     # y â‰¤ 3.5m (å·¦è½¦é“çº¿)

constraint = BoxConstraint(state_min, state_max, control_min, control_max)
# ... åˆ›å»ºèŠ‚ç‚¹å¹¶æ±‚è§£
```

**æ€§èƒ½**: Python å®ç°çº¦ 10 Hz,C++ å®ç°çº¦ 50 Hz

### 2. åœè½¦åœºæ™¯è§„åˆ’

```python
# åœºæ™¯: å¹³è¡Œæ³Šè½¦
# åˆå§‹: [0, 0, 0, 0]
# ç›®æ ‡: [10, 2.5, Ï€/2, 0] (ä¾§æ–¹ä½)

goal = [10, 2.5, np.pi/2, 0]
Q = np.diag([1e-1, 1e0, 1e2, 1e-6])  # å¼ºè°ƒç»ˆç«¯å§¿æ€
# ... æ±‚è§£
```

### 3. é«˜é€ŸåŠ¨æ€é¿éšœ

```python
# ä½¿ç”¨ C++ å®ç°è·å¾—å®æ—¶æ€§èƒ½
from cilqr.al_ilqr_cpp.ilqr_pybind import NewALILQR6_2, QuadraticConstraints6_2

# å®šä¹‰éšœç¢ç‰©çº¦æŸ (æ¤­åœ†)
Q_obs = np.diag([1/4.0, 1/2.0])  # é•¿è½´ 4m, çŸ­è½´ 2m
center = np.array([50, 0])       # éšœç¢ç‰©ä¸­å¿ƒ

# ... åˆ›å»ºæ±‚è§£å™¨å¹¶ä¼˜åŒ–
```

**æ€§èƒ½**: 30 æ­¥è§„åˆ’åœ¨ 15 ms å†…å®Œæˆ

---

## ğŸ—ï¸ æ¶æ„è®¾è®¡

### æ¨¡å—åŒ–è®¾è®¡

```
ç”¨æˆ·å±‚
  â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      ILQR æ±‚è§£å™¨           â”‚  â† ç®—æ³•æ ¸å¿ƒ
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚ è°ƒç”¨
         â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      ILQRNode èŠ‚ç‚¹         â”‚  â† åŠ¨åŠ›å­¦æ¨¡å‹
â”‚  - LatBicycleNode          â”‚
â”‚  - FullBicycleNode         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚ åŒ…å«
         â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚     Constraints çº¦æŸ       â”‚  â† çº¦æŸå¤„ç†
â”‚  - BoxConstraint           â”‚
â”‚  - LinearConstraints       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### æ‰©å±•æ€§

- âœ… æ–°å¢è½¦è¾†æ¨¡å‹: ç»§æ‰¿ `ILQRNode`
- âœ… æ–°å¢çº¦æŸç±»å‹: ç»§æ‰¿ `Constraints`
- âœ… è‡ªå®šä¹‰ä»£ä»·å‡½æ•°: é‡å†™ `cost()` æ–¹æ³•
- âœ… å¤šè¯­è¨€é›†æˆ: pybind11 æ— ç¼æ¡¥æ¥

---

## ğŸ“ˆ æ€§èƒ½åŸºå‡†

### Python vs C++

| åœºæ™¯ | Python | C++ | åŠ é€Ÿæ¯” |
|------|--------|-----|--------|
| æ¨ªå‘æ¨¡å‹ (4D, 30æ­¥) | 485 ms | 14.2 ms | 34x |
| å®Œæ•´æ¨¡å‹ (6D, 30æ­¥) | 720 ms | 22.5 ms | 32x |
| å¸¦éšœç¢ç‰© (4D, 50æ­¥) | 1240 ms | 38.7 ms | 32x |

### å¯æ‰©å±•æ€§æµ‹è¯•

| æ—¶é—´æ­¥æ•° | Python | C++ |
|---------|--------|-----|
| 10 | 165 ms | 5.2 ms |
| 30 | 485 ms | 14.2 ms |
| 50 | 810 ms | 23.8 ms |
| 100 | 1625 ms | 47.5 ms |

**ç»“è®º**: æ—¶é—´å¤æ‚åº¦ O(N),çº¿æ€§å¢é•¿ âœ…

---

## ğŸ› ï¸ å¼€å‘è€…èµ„æº

### é¡¹ç›®ç»“æ„é€ŸæŸ¥

```
cilqr/
â”œâ”€â”€ ilqr.py              # â† ä»è¿™é‡Œå¼€å§‹é˜…è¯»
â”œâ”€â”€ ilqr_node.py         # â† ç†è§£èŠ‚ç‚¹æ¥å£
â”œâ”€â”€ lat_bicycle_node.py  # â† å­¦ä¹ æ¨¡å‹å®ç°
â”œâ”€â”€ constraints.py       # â† æŒæ¡çº¦æŸå¤„ç†
â””â”€â”€ al_ilqr_cpp/
    â”œâ”€â”€ new_al_ilqr.h    # â† C++ æ±‚è§£å™¨å…¥å£
    â””â”€â”€ model/
        â””â”€â”€ new_bicycle_node.h  # â† C++ æ¨¡å‹ç¤ºä¾‹
```

### è°ƒè¯•æŠ€å·§

```python
# 1. æ‰“å°æ¯æ¬¡è¿­ä»£çš„ä»£ä»·
def optimize_with_debug(self, max_iters=20):
    for i in range(max_iters):
        k, K = self.backward()
        x, u = self.forward(k, K)
        cost = self.compute_total_cost()
        print(f"Iter {i}: Cost = {cost:.4f}")
        # ...

# 2. å¯è§†åŒ–çº¦æŸè¿ååº¦
violations = [node.constraints() for node in solver.ilqr_nodes]
plt.plot(violations)
plt.title('Constraint Violations')
plt.show()

# 3. æ£€æŸ¥é›…å¯æ¯”çŸ©é˜µæ­£ç¡®æ€§
from scipy.optimize import approx_fprime
A_numerical = approx_fprime(state, lambda x: node.dynamics(x, control), 1e-8)
A_analytical, _ = node.dynamics_jacobian(state, control)
print(f"Jacobian error: {np.linalg.norm(A_numerical - A_analytical)}")
```

### å•å…ƒæµ‹è¯•

```bash
# Python æµ‹è¯•
cd cilqr
python -m pytest tests/  # å¦‚æœæœ‰ pytest

# C++ æµ‹è¯•
cd cilqr/al_ilqr_cpp
bazel test //...
```

---

## ğŸ”— ç›¸å…³é“¾æ¥

### ç†è®ºèµ„æº

- [iLQG è®ºæ–‡ (Tassa et al., 2012)](https://homes.cs.washington.edu/~todorov/papers/TassaIROS12.pdf)
- [Augmented Lagrangian Methods (Bertsekas)](https://www.mit.edu/people/dimitrib/Constrained-Opt.pdf)
- [Differential Dynamic Programming](https://en.wikipedia.org/wiki/Differential_dynamic_programming)

### å®ç°å‚è€ƒ

- [iLQG MATLAB å®ç°](https://www.mathworks.com/matlabcentral/fileexchange/52069-ilqg-ddp-trajectory-optimization)
- [MuJoCo iLQG](https://github.com/anassinator/ilqr)
- [Crocoddyl (Pinocchio)](https://github.com/loco-3d/crocoddyl)

### å·¥å…·åº“

- [Eigen3 æ–‡æ¡£](https://eigen.tuxfamily.org/dox/)
- [pybind11 æ–‡æ¡£](https://pybind11.readthedocs.io/)
- [Bazel æ–‡æ¡£](https://bazel.build/)

---

## ğŸ“ ç‰ˆæœ¬å†å²

### å½“å‰ç‰ˆæœ¬ç‰¹æ€§

- âœ… Python å’Œ C++ åŒå®ç°
- âœ… å¢å¹¿æ‹‰æ ¼æœ—æ—¥çº¦æŸå¤„ç†
- âœ… å¤šç§è½¦è¾†æ¨¡å‹æ”¯æŒ
- âœ… RK2 é«˜ç²¾åº¦ç§¯åˆ†
- âœ… çº¿æœç´¢ä¿è¯æ”¶æ•›
- âœ… pybind11 Python ç»‘å®š

### è®¡åˆ’ä¸­çš„åŠŸèƒ½

- ğŸ”² è‡ªåŠ¨å¾®åˆ†æ”¯æŒ (CppAD/JAX)
- ğŸ”² GPU åŠ é€Ÿç‰ˆæœ¬
- ğŸ”² å¤šæ®µè½¨è¿¹æ‹¼æ¥
- ğŸ”² åœ¨çº¿ MPC ç¤ºä¾‹
- ğŸ”² ROS é›†æˆåŒ…

---

## ğŸ’¬ è·å–å¸®åŠ©

### å¸¸è§é—®é¢˜

æŸ¥çœ‹ [å¿«é€Ÿå¼€å§‹æŒ‡å— - å¸¸è§é—®é¢˜](02_å¿«é€Ÿå¼€å§‹æŒ‡å—.md#å¸¸è§é—®é¢˜) éƒ¨åˆ†

### è°ƒè¯•æµç¨‹

1. **æ£€æŸ¥è¾“å…¥**: ç¡®è®¤çŠ¶æ€ã€æ§åˆ¶ã€çº¦æŸç»´åº¦æ­£ç¡®
2. **éªŒè¯é›…å¯æ¯”**: ä½¿ç”¨æ•°å€¼å¾®åˆ†å¯¹æ¯”
3. **é™ä½çº¦æŸ**: å…ˆç”¨å®½æ¾çº¦æŸæµ‹è¯•
4. **å¢åŠ æ—¥å¿—**: æ‰“å°æ¯æ¬¡è¿­ä»£çš„å…³é”®å˜é‡
5. **å¯è§†åŒ–**: ç»˜åˆ¶è½¨è¿¹ã€ä»£ä»·ã€çº¦æŸæ›²çº¿

### ç¤¾åŒºæ”¯æŒ

- ğŸ“§ Email: [æ·»åŠ è”ç³»é‚®ç®±]
- ğŸ’¬ Issues: [GitHub Issues é“¾æ¥]
- ğŸ“– Wiki: [é¡¹ç›® Wiki é“¾æ¥]

---

## ğŸ“ å­¦ä¹ è·¯å¾„

### åˆå­¦è€…è·¯å¾„ (1-2 å¤©)

```
Day 1:
  â”œâ”€ é˜…è¯» [é¡¹ç›®æ¦‚è§ˆ](00_é¡¹ç›®æ¦‚è§ˆ.md) (30 min)
  â”œâ”€ å®‰è£…ç¯å¢ƒ [å¿«é€Ÿå¼€å§‹](02_å¿«é€Ÿå¼€å§‹æŒ‡å—.md) (30 min)
  â”œâ”€ è¿è¡Œ test.py ç¤ºä¾‹ (15 min)
  â””â”€ ä¿®æ”¹å‚æ•°è§‚å¯Ÿå½±å“ (45 min)

Day 2:
  â”œâ”€ å­¦ä¹  [ç®—æ³•åŸç†](01_ç®—æ³•åŸç†.md) å‰åŠéƒ¨åˆ† (1 h)
  â”œâ”€ æŸ¥é˜… [API å‚è€ƒ](03_APIå‚è€ƒ.md) - Python éƒ¨åˆ† (1 h)
  â””â”€ ç¼–å†™è‡ªå·±çš„è§„åˆ’åœºæ™¯ (1 h)
```

### è¿›é˜¶è·¯å¾„ (3-5 å¤©)

```
Week 1:
  â”œâ”€ æ·±å…¥ç†è§£ ALM çº¦æŸå¤„ç† (Day 3)
  â”œâ”€ å®ç°è‡ªå®šä¹‰è½¦è¾†æ¨¡å‹ (Day 4)
  â”œâ”€ å­¦ä¹  C++ å®ç°å¹¶ç¼–è¯‘ (Day 5)
  â””â”€ æ€§èƒ½å¯¹æ¯”å’Œä¼˜åŒ– (Day 5)
```

### ä¸“å®¶è·¯å¾„ (1-2 å‘¨)

```
Week 2:
  â”œâ”€ é˜…è¯»æºç ç†è§£å®ç°ç»†èŠ‚
  â”œâ”€ æ·»åŠ æ–°çš„çº¦æŸç±»å‹
  â”œâ”€ è´¡çŒ®ä»£ç æˆ–æ–‡æ¡£
  â””â”€ é›†æˆåˆ°å®é™…é¡¹ç›®
```

---

## âœ¨ äº®ç‚¹åŠŸèƒ½

### 1. è‡ªé€‚åº”å‚æ•°è°ƒèŠ‚

ALM å‚æ•°æ ¹æ®çº¦æŸè¿ååº¦è‡ªåŠ¨è°ƒæ•´:
```python
if violation < 1e-3:
    # æ”¶æ•›
elif violation < 1e-1:
    update_lambda()  # æ›´æ–°ä¹˜å­
else:
    update_mu(8.0)   # å¢å¤§æƒ©ç½š
```

### 2. æ•°å€¼ç¨³å®šæ€§ä¿è¯

- è§’åº¦å½’ä¸€åŒ–é¿å…è·³å˜
- Hessian æ­£åˆ™åŒ–é˜²æ­¢å¥‡å¼‚
- çº¿æœç´¢ä¿è¯ä»£ä»·ä¸‹é™

### 3. æ¨¡æ¿å…ƒç¼–ç¨‹åŠ é€Ÿ

C++ æ¨¡æ¿åœ¨ç¼–è¯‘æ—¶ç¡®å®šç»´åº¦,é›¶è¿è¡Œæ—¶å¼€é”€:
```cpp
template<int state_dim, int control_dim>
class NewALILQR {
    using VectorState = Eigen::Matrix<double, state_dim, 1>;
    // ç¼–è¯‘æ—¶ç¡®å®šå¤§å°,æ ˆä¸Šåˆ†é…,æå¿«!
};
```

---

## ğŸ† æœ€ä½³å®è·µ

### ä»£ä»·å‡½æ•°è®¾è®¡

```python
# âœ… å¥½çš„è®¾è®¡
Q = np.diag([1e-3, 1e-1, 1e1, 1e-9])  # æ˜ç¡®ä¼˜å…ˆçº§
R = np.array([[50.0]])                # æƒ©ç½šå¤§çš„æ§åˆ¶å˜åŒ–

# âŒ é¿å…
Q = np.eye(4)  # æƒé‡ç›¸åŒ,å¯èƒ½å¯¼è‡´å¥‡æ€ªè¡Œä¸º
R = np.array([[1e-6]])  # å¤ªå°,æ§åˆ¶ä¼šå‰§çƒˆå˜åŒ–
```

### çº¦æŸè®¾ç½®

```python
# âœ… æ¸è¿›å¼è°ƒè¯•
# Step 1: æ— çº¦æŸæˆ–å®½æ¾çº¦æŸ
state_bounds = np.array([[-1000, -1000, -2*np.pi, -1.0],
                         [1000, 1000, 2*np.pi, 1.0]])

# Step 2: é€æ¸æ”¶ç´§
state_bounds = np.array([[-100, -5, -np.pi, -0.5],
                         [100, 5, np.pi, 0.5]])

# Step 3: æœ€ç»ˆçº¦æŸ
state_bounds = np.array([[-50, -3.5, -np.pi/4, -0.3],
                         [50, 3.5, np.pi/4, 0.3]])
```

### æ€§èƒ½ä¼˜åŒ–

```python
# é€‰æ‹©åˆé€‚çš„å®ç°
if development_phase:
    use Python  # å¿«é€Ÿè¿­ä»£
elif production_phase:
    use C++ with pybind  # æœ€é«˜æ€§èƒ½
```

---

**æ–‡æ¡£ç»´æŠ¤**: iLQR Solver Team
**æœ€åæ›´æ–°**: 2025-10-11
**ç‰ˆæœ¬**: v1.0

---

## å¼€å§‹ä½ çš„ iLQR ä¹‹æ—…! ğŸš—ğŸ’¨

ä» [é¡¹ç›®æ¦‚è§ˆ](00_é¡¹ç›®æ¦‚è§ˆ.md) å¼€å§‹,æˆ–ç›´æ¥è·³åˆ° [å¿«é€Ÿå¼€å§‹æŒ‡å—](02_å¿«é€Ÿå¼€å§‹æŒ‡å—.md) åŠ¨æ‰‹å®è·µ!
